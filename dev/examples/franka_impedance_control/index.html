<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Franka Impedance Control · VMRobotControl.jl</title><meta name="title" content="Franka Impedance Control · VMRobotControl.jl"/><meta property="og:title" content="Franka Impedance Control · VMRobotControl.jl"/><meta property="twitter:title" content="Franka Impedance Control · VMRobotControl.jl"/><meta name="description" content="Documentation for VMRobotControl.jl."/><meta property="og:description" content="Documentation for VMRobotControl.jl."/><meta property="twitter:description" content="Documentation for VMRobotControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VMRobotControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/building/">Building a mechanism</a></li><li><a class="tocitem" href="../../tutorials/using/">Using a mechanism</a></li><li><a class="tocitem" href="../../tutorials/vms/">Virtual Model Control of a Simulated Robot</a></li><li><a class="tocitem" href="../../tutorials/plotting/">Plotting with Makie.jl</a></li><li><a class="tocitem" href="../../tutorials/simulating/">Simulating with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/control/">Virtual Model Control of a Real Robot using ROS</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Optimization</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Franka Impedance Control</a><ul class="internal"><li><a class="tocitem" href="#Loading/Building-the-Robot-and-Controller"><span>Loading/Building the Robot and Controller</span></a></li><li><a class="tocitem" href="#Setting-up-the-simulation"><span>Setting up the simulation</span></a></li><li><a class="tocitem" href="#Visualizing-the-simulation"><span>Visualizing the simulation</span></a></li></ul></li><li><a class="tocitem" href="../sciurus_reaching/">Sciurus reaching with obstacle avoidance</a></li><li><a class="tocitem" href="../compliant_path_following/">Franka compliant path following</a></li><li><a class="tocitem" href="../rail_robot/">Pendulum on a Bezier-Spline Rail</a></li></ul></li><li><a class="tocitem" href="../../api/api/">API</a></li><li><a class="tocitem" href="../../developer/developer/">Developer Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Franka Impedance Control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Franka Impedance Control</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Cambridge-Control-Lab/VMRobotControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Cambridge-Control-Lab/VMRobotControl.jl/blob/main/docs/src/examples/franka_impedance_control.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Franka-Impedance-Control-PD-in-task-space"><a class="docs-heading-anchor" href="#Franka-Impedance-Control-PD-in-task-space">Franka Impedance Control - PD in task space</a><a id="Franka-Impedance-Control-PD-in-task-space-1"></a><a class="docs-heading-anchor-permalink" href="#Franka-Impedance-Control-PD-in-task-space" title="Permalink"></a></h1><p>Impedance control is a control strategy that is used to control a robot by designing a force/position relationship rather than employing either position control or force control independantly. A standard, 6DOF, end-effector impedance controller uses a PD feedback in end-effector space to create a desired force/position relationship. We interpret this as the end-effector being connected to the world by a spring-damper system, and present here an implementation of this controller for a Franka Emika robot.</p><pre><code class="language-julia hljs">using DifferentialEquations
using GeometryBasics: Vec3f, Point3f
using GLMakie
using LinearAlgebra
using MeshIO
using StaticArrays
using VMRobotControl</code></pre><h2 id="Loading/Building-the-Robot-and-Controller"><a class="docs-heading-anchor" href="#Loading/Building-the-Robot-and-Controller">Loading/Building the Robot and Controller</a><a id="Loading/Building-the-Robot-and-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Loading/Building-the-Robot-and-Controller" title="Permalink"></a></h2><p>First we have to load the model of the robot, which uses the URDF file format. Because the meshes for the franka robot are in the DAE file format, which is not natively supported by Julia&#39;s MeshIO/FileIO, we have to manually register the DAE file format to be able to load</p><pre><code class="language-julia hljs">using FileIO, UUIDs
try
    FileIO.add_format(format&quot;DAE&quot;, (), &quot;.dae&quot;, [:DigitalAssetExchangeFormatIO =&gt; UUID(&quot;43182933-f65b-495a-9e05-4d939cea427d&quot;)])
catch
end
cfg = URDFParserConfig(;suppress_warnings=true) # This is just to hide warnings about unsupported URDF features
module_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])
robot = parseURDF(joinpath(module_path, &quot;URDFs/franka_description/urdfs/fr3.urdf&quot;), cfg)</code></pre><pre><code class="nohighlight hljs">7DOF Mechanism{Float64} &quot;fr3&quot; with 10 frames, 9 joints, 16 coordinates, 44 components</code></pre><p>Now, we begin adding gravity compensation to the robot model, as the franka robot does its own gravity compensation. We also add some damping to each joint to make the simulation more realistic so that the robot does not oscillate indefinitely.</p><pre><code class="language-julia hljs">add_gravity_compensation!(robot, VMRobotControl.DEFAULT_GRAVITY)
for i in 1:7
    add_coordinate!(robot, JointSubspace(&quot;fr3_joint$i&quot;);    id=&quot;J$i&quot;)
    add_component!(robot, LinearDamper(0.1, &quot;J$i&quot;);         id=&quot;Joint damper $i&quot;)
end;</code></pre><p>Now, we build the virtual mechanism controller, which will control the position and orientation of the end effector of the robot. We define several coordinates, starting with the TCP position and orientation, and then the target position, and the position error.</p><p>A <code>FramePoint</code> coordinate is used to represent the position of the TCP, which is a point in the frame of the final link of the robot. The <code>QuaternionAttitude</code> component is used to represent the orientation of the TCP, which is a quaternion. The <code>CoordDifference</code> component is used to take the difference between the target position and the current position of the TCP.</p><pre><code class="language-julia hljs">target_rot = AxisAngle(SVector(0., 1., 0.), Float64(π))
vms = VirtualMechanismSystem(&quot;franka_impedance_control&quot;, robot)
add_coordinate!(robot, FramePoint(&quot;fr3_link8&quot;, SVector(0., 0., 0.));            id=&quot;TCP position&quot;)
add_coordinate!(vms, QuaternionAttitude(&quot;.robot.fr3_link8&quot;, target_rot);        id=&quot;TCP orientation&quot;)
root = root_frame(vms.robot)
add_coordinate!(vms, FramePoint(&quot;.robot.$root&quot;, SVector(0.4, 0.0, 0.2));        id=&quot;Target position&quot;)
add_coordinate!(vms, CoordDifference(&quot;.robot.TCP position&quot;, &quot;Target position&quot;); id=&quot;Position error&quot;);</code></pre><p>We then add a linear spring-damper components onto the defined coordinates. The linear spring-damper components will act as the impedance controller, which will try to keep the end effector at a fixed position and orientation.</p><p>We use different stiffness and damping values in different directions, to demonstrate the flexibility of the impedance controller: e.g. a linear stiffness of 100 N/m in the x-direction, 200 N/m in the y-direction, and 300 N/m in the z-direction, and similarly for the damping values.</p><pre><code class="language-julia hljs">K = SMatrix{3, 3}(100., 0., 0., 0., 200., 0., 0., 0., 300.)
add_component!(vms, LinearSpring(K, &quot;Position error&quot;);           id=&quot;Linear Spring&quot;)
D = SMatrix{3, 3}(10., 0., 0., 0., 20.0, 0., 0., 0., 30.)
add_component!(vms, LinearDamper(D, &quot;Position error&quot;);           id=&quot;Linear Damper&quot;)
K_rot = SMatrix{3, 3}(10., 0., 0., 0., 20., 0., 0., 0., 30.)
add_component!(vms, LinearSpring(K_rot, &quot;TCP orientation&quot;);       id=&quot;Angular Spring&quot;)
D_rot = SMatrix{3, 3}(0.1, 0., 0., 0., 0.2, 0., 0., 0., 0.3)
add_component!(vms, LinearDamper(D_rot, &quot;TCP orientation&quot;);       id=&quot;Angular Damper&quot;);</code></pre><h2 id="Setting-up-the-simulation"><a class="docs-heading-anchor" href="#Setting-up-the-simulation">Setting up the simulation</a><a id="Setting-up-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-simulation" title="Permalink"></a></h2><p>We define a disturbance function that will apply a force of 10 N in the y-direction for the first 3 seconds of the simulation. We then define the <code>f_control</code> to apply this disturbance force to the system, as <code>f_control</code> is called once per timestep of the simulation, and can be used to apply external forces to the system. Function <code>f_setup</code> is used to get the coordinate ID of the TCP position at the beginning of the simulation, to be used in the <code>f_control</code> function.</p><p>We then define the timespan, initial joint angles, joint velocities, and gravity vector for the simulation. We create a dynamics cache, and an ODE problem, and solve the ODE problem using the Tsit5 solver from DifferentialEquations.jl.</p><pre><code class="language-julia hljs">disturbance_func(t) = mod(t, 6) &lt; 3 ? SVector(0., 0., 0.) : SVector(0., 10.0, 0.)
f_setup(cache) = get_compiled_coordID(cache, &quot;.robot.TCP position&quot;)
function f_control(cache, t, args, extra)
    tcp_pos_coord_id = args
    F = disturbance_func(t)
    uᵣ, uᵥ = get_u(cache)
    z = configuration(cache, tcp_pos_coord_id)
    J = jacobian(cache, tcp_pos_coord_id)
    mul!(uᵣ, J&#39;, F)
    nothing
end
tspan = (0., 12.)
q = ([0.0, 0.3, 0.0, -1.8, 0.0, π/2, 0.0], Float64[]) # Robot joint angle, vm joint angles
q̇ = ([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float64[]) # Robot joint velocity, vm joint velocities
g = VMRobotControl.DEFAULT_GRAVITY
dcache = new_dynamics_cache(compile(vms))
prob = get_ode_problem(dcache, g, q, q̇, tspan; f_setup, f_control)
@info &quot;Simulating franka robot with impedance control.&quot;
sol = solve(prob, Tsit5(); maxiters=1e5, abstol=1e-6, reltol=1e-6);</code></pre><pre><code class="nohighlight hljs">[ Info: Simulating franka robot with impedance control.
</code></pre><h2 id="Visualizing-the-simulation"><a class="docs-heading-anchor" href="#Visualizing-the-simulation">Visualizing the simulation</a><a id="Visualizing-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-simulation" title="Permalink"></a></h2><p>We create a figure, and a 3D scene, and set the camera position to a good view of the robot. We create an observable for the time, and the kinematics cache, which will used by the function <code>animate_robot_odesolution</code> to update any plots that depend upon these observables. We then visualize the robot, and the force arrow that is applied to the end effector of the robot. We then animate the simulation, and save the animation to a file.</p><pre><code class="language-julia hljs">fig = Figure(size = (720, 720), figure_padding=0)
display(fig)
ls = LScene(fig[1, 1]; show_axis=false)
cam = cam3d!(ls, camera=:perspective, center=false)
cam.lookat[] = [0.24015087703685004, -0.02303109659518269, 0.37391966173978597]
cam.eyeposition[] = [0.5360994756635347, 0.7578567808643422, 0.5303480879908374]

plotting_t = Observable(0.0)
plotting_kcache = Observable(new_kinematics_cache(compile(robot)))
robotvisualize!(ls, plotting_kcache;)

tcp_pos_id = get_compiled_coordID(plotting_kcache[], &quot;TCP position&quot;)
tcp_pos = map(plotting_kcache) do kcache
    Point3f(configuration(kcache, tcp_pos_id))
end
force = map(t -&gt; 0.01 * Vec3f(disturbance_func(t)), plotting_t)
arrowsize = map(f -&gt; 0.1*(f&#39;*f)^(0.25), force)
arrows!(ls, map(p -&gt; [p], tcp_pos), map(f -&gt; [f], force); color = :red, arrowsize)


savepath = joinpath(module_path, &quot;docs/src/assets/franka_impedance_control.mp4&quot;)
animate_robot_odesolution(fig, sol, plotting_kcache, savepath; t=plotting_t);</code></pre><video controls width="100%" height="auto" autoplay loop>
<source src="../../assets/franka_impedance_control.mp4" type="video/mp4">
</video><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/optimization/">« Optimization</a><a class="docs-footer-nextpage" href="../sciurus_reaching/">Sciurus reaching with obstacle avoidance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 21 January 2025 15:10">Tuesday 21 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
