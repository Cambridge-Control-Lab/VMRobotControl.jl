var documenterSearchIndex = {"docs":
[{"location":"examples/franka_impedance_control/#Franka-Impedance-Control-PD-in-task-space","page":"Franka Impedance Control","title":"Franka Impedance Control - PD in task space","text":"","category":"section"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"Impedance control is a control strategy that is used to control a robot by designing a force/position relationship rather than employing either position control or force control independantly. A standard, 6DOF, end-effector impedance controller uses a PD feedback in end-effector space to create a desired force/position relationship. We interpret this as the end-effector being connected to the world by a spring-damper system, and present here an implementation of this controller for a Franka Emika robot.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"using DifferentialEquations\nusing GeometryBasics: Vec3f, Point3f\nusing GLMakie\nusing LinearAlgebra\nusing MeshIO\nusing StaticArrays\nusing VMRobotControl","category":"page"},{"location":"examples/franka_impedance_control/#Loading/Building-the-Robot-and-Controller","page":"Franka Impedance Control","title":"Loading/Building the Robot and Controller","text":"","category":"section"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"First we have to load the model of the robot, which uses the URDF file format. Because the meshes for the franka robot are in the DAE file format, which is not natively supported by Julia's MeshIO/FileIO, we have to manually register the DAE file format to be able to load","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"using FileIO, UUIDs\ntry\n    FileIO.add_format(format\"DAE\", (), \".dae\", [:DigitalAssetExchangeFormatIO => UUID(\"43182933-f65b-495a-9e05-4d939cea427d\")])\ncatch\nend\ncfg = URDFParserConfig(;suppress_warnings=true) # This is just to hide warnings about unsupported URDF features\nmodule_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])\nrobot = parseURDF(joinpath(module_path, \"URDFs/franka_description/urdfs/fr3.urdf\"), cfg)","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"7DOF Mechanism{Float64} \"fr3\" with 10 frames, 9 joints, 16 coordinates, 44 components","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"Now, we begin adding gravity compensation to the robot model, as the franka robot does its own gravity compensation. We also add some damping to each joint to make the simulation more realistic so that the robot does not oscillate indefinitely.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"add_gravity_compensation!(robot, VMRobotControl.DEFAULT_GRAVITY)\nfor i in 1:7\n    add_coordinate!(robot, JointSubspace(\"fr3_joint$i\");    id=\"J$i\")\n    add_component!(robot, LinearDamper(0.1, \"J$i\");         id=\"Joint damper $i\")\nend;","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"Now, we build the virtual mechanism controller, which will control the position and orientation of the end effector of the robot. We define several coordinates, starting with the TCP position and orientation, and then the target position, and the position error.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"A FramePoint coordinate is used to represent the position of the TCP, which is a point in the frame of the final link of the robot. The QuaternionAttitude component is used to represent the orientation of the TCP, which is a quaternion. The CoordDifference component is used to take the difference between the target position and the current position of the TCP.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"target_rot = AxisAngle(SVector(0., 1., 0.), Float64(π))\nvms = VirtualMechanismSystem(\"franka_impedance_control\", robot)\nadd_coordinate!(robot, FramePoint(\"fr3_link8\", SVector(0., 0., 0.));            id=\"TCP position\")\nadd_coordinate!(vms, QuaternionAttitude(\".robot.fr3_link8\", target_rot);        id=\"TCP orientation\")\nroot = root_frame(vms.robot)\nadd_coordinate!(vms, FramePoint(\".robot.$root\", SVector(0.4, 0.0, 0.2));        id=\"Target position\")\nadd_coordinate!(vms, CoordDifference(\".robot.TCP position\", \"Target position\"); id=\"Position error\");","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"We then add a linear spring-damper components onto the defined coordinates. The linear spring-damper components will act as the impedance controller, which will try to keep the end effector at a fixed position and orientation.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"We use different stiffness and damping values in different directions, to demonstrate the flexibility of the impedance controller: e.g. a linear stiffness of 100 N/m in the x-direction, 200 N/m in the y-direction, and 300 N/m in the z-direction, and similarly for the damping values.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"K = SMatrix{3, 3}(100., 0., 0., 0., 200., 0., 0., 0., 300.)\nadd_component!(vms, LinearSpring(K, \"Position error\");           id=\"Linear Spring\")\nD = SMatrix{3, 3}(10., 0., 0., 0., 20.0, 0., 0., 0., 30.)\nadd_component!(vms, LinearDamper(D, \"Position error\");           id=\"Linear Damper\")\nK_rot = SMatrix{3, 3}(10., 0., 0., 0., 20., 0., 0., 0., 30.)\nadd_component!(vms, LinearSpring(K_rot, \"TCP orientation\");       id=\"Angular Spring\")\nD_rot = SMatrix{3, 3}(0.1, 0., 0., 0., 0.2, 0., 0., 0., 0.3)\nadd_component!(vms, LinearDamper(D_rot, \"TCP orientation\");       id=\"Angular Damper\");","category":"page"},{"location":"examples/franka_impedance_control/#Setting-up-the-simulation","page":"Franka Impedance Control","title":"Setting up the simulation","text":"","category":"section"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"We define a disturbance function that will apply a force of 10 N in the y-direction for the first 3 seconds of the simulation. We then define the f_control to apply this disturbance force to the system, as f_control is called once per timestep of the simulation, and can be used to apply external forces to the system. Function f_setup is used to get the coordinate ID of the TCP position at the beginning of the simulation, to be used in the f_control function.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"We then define the timespan, initial joint angles, joint velocities, and gravity vector for the simulation. We create a dynamics cache, and an ODE problem, and solve the ODE problem using the Tsit5 solver from DifferentialEquations.jl.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"disturbance_func(t) = mod(t, 6) < 3 ? SVector(0., 0., 0.) : SVector(0., 10.0, 0.)\nf_setup(cache) = get_compiled_coordID(cache, \".robot.TCP position\")\nfunction f_control(cache, t, args, extra)\n    tcp_pos_coord_id = args\n    F = disturbance_func(t)\n    uᵣ, uᵥ = get_u(cache)\n    z = configuration(cache, tcp_pos_coord_id)\n    J = jacobian(cache, tcp_pos_coord_id)\n    mul!(uᵣ, J', F)\n    nothing\nend\ntspan = (0., 12.)\nq = ([0.0, 0.3, 0.0, -1.8, 0.0, π/2, 0.0], Float64[]) # Robot joint angle, vm joint angles\nq̇ = ([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Float64[]) # Robot joint velocity, vm joint velocities\ng = VMRobotControl.DEFAULT_GRAVITY\ndcache = new_dynamics_cache(compile(vms))\nprob = get_ode_problem(dcache, g, q, q̇, tspan; f_setup, f_control)\n@info \"Simulating franka robot with impedance control.\"\nsol = solve(prob, Tsit5(); maxiters=1e5, abstol=1e-6, reltol=1e-6);","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"[ Info: Simulating franka robot with impedance control.\n","category":"page"},{"location":"examples/franka_impedance_control/#Visualizing-the-simulation","page":"Franka Impedance Control","title":"Visualizing the simulation","text":"","category":"section"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"We create a figure, and a 3D scene, and set the camera position to a good view of the robot. We create an observable for the time, and the kinematics cache, which will used by the function animate_robot_odesolution to update any plots that depend upon these observables. We then visualize the robot, and the force arrow that is applied to the end effector of the robot. We then animate the simulation, and save the animation to a file.","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"fig = Figure(size = (720, 720), figure_padding=0)\ndisplay(fig)\nls = LScene(fig[1, 1]; show_axis=false)\ncam = cam3d!(ls, camera=:perspective, center=false)\ncam.lookat[] = [0.24015087703685004, -0.02303109659518269, 0.37391966173978597]\ncam.eyeposition[] = [0.5360994756635347, 0.7578567808643422, 0.5303480879908374]\n\nplotting_t = Observable(0.0)\nplotting_kcache = Observable(new_kinematics_cache(compile(robot)))\nrobotvisualize!(ls, plotting_kcache;)\n\ntcp_pos_id = get_compiled_coordID(plotting_kcache[], \"TCP position\")\ntcp_pos = map(plotting_kcache) do kcache\n    Point3f(configuration(kcache, tcp_pos_id))\nend\nforce = map(t -> 0.01 * Vec3f(disturbance_func(t)), plotting_t)\narrowsize = map(f -> 0.1*(f'*f)^(0.25), force)\narrows!(ls, map(p -> [p], tcp_pos), map(f -> [f], force); color = :red, arrowsize)\n\n\nsavepath = joinpath(module_path, \"docs/src/assets/franka_impedance_control.mp4\")\nanimate_robot_odesolution(fig, sol, plotting_kcache, savepath; t=plotting_t);","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"<video controls width=\"100%\" height=\"auto\" autoplay loop>\n<source src=\"../../assets/franka_impedance_control.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"","category":"page"},{"location":"examples/franka_impedance_control/","page":"Franka Impedance Control","title":"Franka Impedance Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/vms/#Virtual-Model-Control-of-a-Simulated-Robot","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"","category":"section"},{"location":"tutorials/vms/#What-is-a-virtual-mechanism-system?","page":"Virtual Model Control of a Simulated Robot","title":"What is a virtual mechanism system?","text":"","category":"section"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"A virtual mechanism system is contains a model of the robot, a model of a virtual mechanism and  interface components that act between the robot and the virtual mechanism. It can be used for two purposes: either for simulation or for control of a real robot. If used for simulation, a full robot model is needed, with dynamic components (like mass/inertia). If used for control, the robot model is still needed, but at a minimum only a kinematics model is needed (frames, joints and coordinates) so no inertial model is nescessary. When controlling a real robot, components on the robot are ignored.","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"The VirtualMechanismSystem thus contains a robot::Mechanism, a  virtual_mechanism::Mechanism, which can be built just like a robot, and also contains it's own coordinates and components that connect between the robot and virtual mechanism.","category":"page"},{"location":"tutorials/vms/#Connecting-a-spring/damper-between-a-robot-and-a-virtual-mechanism.","page":"Virtual Model Control of a Simulated Robot","title":"Connecting a spring/damper between a robot and a virtual mechanism.","text":"","category":"section"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"First, lets build a super simple virtual mechanism system. It will consist of a 1DOF robot, and a 1DOF virtual mechanism. A virtual spring and damper will join the two together.","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"First, we make the robot, virtual mechanism, and virtual mechanism system.","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"using VMRobotControl, StaticArrays\n\nrobot = Mechanism{Float64}(\"Piston\")\nadd_frame!(robot, \"L1\")\nadd_joint!(robot, Prismatic(SVector(1.0, 0.0, 0.0)); parent=\"root_frame\", child=\"L1\", id=\"J1\")\nadd_coordinate!(robot, FrameOrigin(\"L1\"); id=\"ee_pos\")\nvirtual_mechanism = deepcopy(robot)\nvms = VirtualMechanismSystem(\"MySystem\", robot, virtual_mechanism)","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"Then, we add a coordinate to the virtual mechanism system using CoordDifference which will is the typical way to define a coordinate between the robot and virtual mechanism. It represents a vector from the tip of the robot end-effector to the tip of the virtual mechanism end-effector. To identify robot/virtual mechanism coordinates from the virtual-mechanism-system, the prefixes \".robot.\" or \".virtual_mechanism.\" must be used.","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"add_coordinate!(vms, CoordDifference(\".robot.ee_pos\", \".virtual_mechanism.ee_pos\"); id=\"ee_err\")\nadd_component!(vms, LinearSpring(100.0, \"ee_err\"); id=\"ee_spring\")\nadd_component!(vms, LinearDamper(1.0, \"ee_err\"); id=\"ee_damper\")","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"We can only add spring/damper like components to the virtual mechanism system, and not inertias/ masses/inertances. This is because the robot/virtual mechanism both act as admitances (taking forces as input, and  computing accelerations as outputs), so the interface between them must act as an impedance (taking motion as input and returning a force).","category":"page"},{"location":"tutorials/vms/#Using-a-virtual-mechanism-system","page":"Virtual Model Control of a Simulated Robot","title":"Using a virtual mechanism system","text":"","category":"section"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"The interface for using a virtual mechanism system is broadly the same as for using mechanism. However, joint configurations, velocities and actuation torques must now be tuples, with the  first entry corresponding to the robot and the second to the virtual mechanism","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"m = compile(vms)\nt = 0.0\nq = zero_q(m)\nkcache = new_kinematics_cache(m)\nkinematics!(kcache, t, q)","category":"page"},{"location":"tutorials/vms/","page":"Virtual Model Control of a Simulated Robot","title":"Virtual Model Control of a Simulated Robot","text":"Note that q is a tuple ","category":"page"},{"location":"tutorials/optimization/#Optimization/Algorithmic-Differentiation","page":"Optimization","title":"Optimization/Algorithmic Differentiation","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"Once you have designed a virtual mechanism controller, you will want to tune the parameters. You can do that by hand or optimize numerically.","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"Algorithmic Differentiation (AD) is incredibly useful for optimization, as you can easily compute  a gradient to speed up the search for the best parameters. There are two tested ways to perform Algorithmic Differentation (AD) with this package. The first and most reliable is using ForwardDiff.jl, and the other using Enzyme.jl.","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"ForwardDiff is easier to use but scales poorly with the number of parameters. Enzyme is harder  to use and does not work over the entire interface. However, it can use reverse mode/ backpropagation, so scales extremely well for large numbers of parameters.","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"This topic is for advanced users, and requires a strong understanding of julia. ","category":"page"},{"location":"tutorials/optimization/#Using-ForwardDiff.jl","page":"Optimization","title":"Using ForwardDiff.jl","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"As ForwardDiff.jl uses dual numbers you will get an error if you try to compute directly. This is because by default, the any cache created uses the type Float64.","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"using ForwardDiff, VMRobotControl\nrobot = parseRSON(\"../../../RSONs/rsons/simple2link.rson\")\nm = compile(robot)\ncache = new_kinematics_cache(m)\nt = 0.0\nEE_frame = get_compiled_frameID(m, \"EE_frame\")\n\ntry\n    results = ForwardDiff.gradient([1.0, 2.0]) do q\n        kinematics!(cache, t, q)\n        o = origin(get_transform(m, EE_frame))\n        return o\n    end\ncatch e\n    print(e)\nend\nnothing","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"Instead, you can wrap the cache in type EltypeCache. To access a concrete cache with element type T, use the syntax eltype_cache[T]. This will create a cache if one does not already exist, or return the existing cache.","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"eltype_cache = let m=m\n    # This let block is required. If it is not used, then the type of m is not known.\n    # By introducing a hard scope, the type is fixed.\n    initializer = (T) -> new_kinematics_cache(m, T)\n    VMRobotControl.EltypeCache(initializer)\nend\n\nresults = ForwardDiff.jacobian([1.0, 2.0]) do q\n    T = eltype(q)\n    cache = eltype_cache[T]\n    kinematics!(cache, t, q)\n    o = origin(get_transform(cache, EE_frame))\n    return o\nend","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"This can also be used in conjunction with DifferentialEquations.jl, to differentiate through a simulation:","category":"page"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"using DifferentialEquations\n\neltype_cache = let m=m\n    initializer = (T) -> new_dynamics_cache(m, T)\n    VMRobotControl.EltypeCache(initializer)\nend\n\nEE_frame = get_compiled_frameID(m, \"EE_frame\")\n\nresults = ForwardDiff.gradient([1.0, 2.0]) do q\n    T = eltype(q)\n    cache = eltype_cache[T]\n    g, q̇, tspan = VMRobotControl.DEFAULT_GRAVITY, zero(q), 5.0\n    prob = get_ode_problem(cache, g, q, q̇, tspan, )\n    sol = solve(prob)\n    \n    x = sol(tspan) # Get final state\n    dynamics!(cache, tspan, x[q_idxs(m)], x[q̇_idxs(m)], g) # Compute using final state\n    o = origin(get_transform(cache, EE_frame))\n    return sqrt(o' * o)\nend","category":"page"},{"location":"tutorials/optimization/#Using-Enzyme.jl","page":"Optimization","title":"Using Enzyme.jl","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Optimization","title":"Optimization","text":"For examples of using Enzyme look at ./test/Enzyme_compat_test. At the time of writing, this works for nearly everything, except computing inertance matrices, and thus dynamics.","category":"page"},{"location":"tutorials/building/#Building-a-Mechanism","page":"Building a mechanism","title":"Building a Mechanism","text":"","category":"section"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Let's build a model robot: a 3DOF arm on a 2DOF sliding table, using 2 prismatic joints followed by 2 revolute joints.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"We will supplement this intro with pictures/videos, but not present the plotting code here. To learn more about plotting, you may read the section Plotting with Makie.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"using GLMakie\nusing DifferentialEquations","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"using VMRobotControl\nusing StaticArrays\nusing LinearAlgebra","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"To begin we make the mechanism and use add_frame! to add the named rigid-body-frames that we will use. All the frames must be joined in a tree from the root frame of the mechanism  which is called \"root_frame\":","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"mechanism = Mechanism{Float64}(\"TableArmRobot\")\nF0 = root_frame(mechanism)","category":"page"},{"location":"tutorials/building/#Adding-rigid-body-frames-and-joints","page":"Building a mechanism","title":"Adding rigid body frames and joints","text":"","category":"section"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Lets add our named frames. Note that add_frame! returns the name of the frame (as a string) for convenience.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"F1 = add_frame!(mechanism; id=\"L1_frame\")\nF2 = add_frame!(mechanism; id=\"L2_frame\")\nF3 = add_frame!(mechanism; id=\"L3_frame\")\nF4 = add_frame!(mechanism; id=\"L4_frame\")\nF5 = add_frame!(mechanism; id=\"L5_frame\")\nF_EE = add_frame!(mechanism; id=\"EE_frame\")","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Now: how do we define the joints that join these frames together? First we must define the joint data. The form of the joint data depends on the type of joint: a Rigid joint needs a [Transform] whereas a Revolute or Prismatic  joint requires the axis of rotation/translation (and optionally a transform too!). This is not a minimal representation (such as denavit hartenburg) but it is a  flexible representation.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"# Define the unit vectors to make things easier\nX = SVector(1., 0., 0.)\nY = SVector(0., 1., 0.)\nZ = SVector(0., 0., 1.)\n\n# First two prismatic joints, one in the X, direction, one in Y\nJ1 = Prismatic(X)\nJ2 = Prismatic(Y)\n# Then a simple articulated arm: J3 rotates around Z, J4 is the shoulder, \n# and J5 the elbow.\nJ3 = Revolute(Z)\nJ4 = Revolute(X)\nJ5 = Revolute(X, Transform(0.4*Z)) \n# Transform(::SVector{3}) is a translation, so J5 is 40cm above J4.\n\n# Finally define a rigid joint that will connect the elbow to end-effector \n# frame, again 40cm above J5\nJ_EE = Rigid(Transform(0.4*Z))","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Now that we have defined the joints, we must add them to the mechanism by  specifying which frames they each connect, and giving each joint an ID (a name), using add_joint!.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"add_joint!(mechanism, J1; parent=F0, child=F1, id=\"J1\")\nadd_joint!(mechanism, J2; parent=F1, child=F2, id=\"J2\")\nadd_joint!(mechanism, J3; parent=F2, child=F3, id=\"J3\")\nadd_joint!(mechanism, J4; parent=F3, child=F4, id=\"J4\")\nadd_joint!(mechanism, J5; parent=F4, child=F5, id=\"J5\")\nadd_joint!(mechanism, J_EE; parent=F5, child=F_EE, id=\"J_EE\")","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Let's inspect our mechanism now:","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"mechanism\nframes(mechanism)\njoints(mechanism)","category":"page"},{"location":"tutorials/building/#Adding-mass,-inertia,-and-damping","page":"Building a mechanism","title":"Adding mass, inertia, and damping","text":"","category":"section"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Now, the rigid body tree of our robot is defined.  However to do simulations we need to give it some mass and inertia. Mass, inertia, damping and other dynamic effects are achieved by adding components to the mechanism. These are generally added using the function add_component!, but there are  some special helper functions like add_inertia!, to help in certain cases.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Point masses are defined by their mass, and a coordinate.  The coordinate should represent the centre of mass, in the root frame of the mechanism. To do this we use the FrameOrigin and FramePoint coordinate types. The configuration of a FrameOrigin coordinate is the position of the origin of a frame,  represented in the root frame. The configuration of a FramePoint coordinate is the position of a point in a frame, represented in the root frame.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"add_coordinate!(mechanism, FrameOrigin(F2); id=\"base_centre_of_mass\")\nadd_coordinate!(mechanism, FrameOrigin(F5); id=\"elbow_centre_of_mass\")\nadd_coordinate!(mechanism, FramePoint(F_EE, 0.2*Z); id=\"ee_centre_of_mass\")\n\nadd_component!(mechanism, PointMass(10.0, \"base_centre_of_mass\"); id=\"base_mass\") \nadd_component!(mechanism, PointMass(2.0, \"elbow_centre_of_mass\"); id=\"lower_arm_mass\") \nadd_component!(mechanism, PointMass(1.0, \"ee_centre_of_mass\"); id=\"ee_mass\") \n\nI_mat = @SMatrix [\n    0.01  0.    0.  ;\n    0.    0.01  0.  ;\n    0.    0.    0.01\n]\nadd_inertia!(mechanism, F3, I_mat; id=\"L3_inertia\")","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"If there are insufficient point masses/inertias the robot inertance matrix will be singular, and you will not be able to solve the dynamics. This happens because at least one of the joints can accelerate without a  point mass or inertia accelerating, so the computed acceleration of the joint would be infinite.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"fig = Figure(size=(854, 480))\nls = LScene(fig[1, 1]; show_axis=false)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\nrobotsketch!(ls, kcache; linewidth=2.0)\nq, q̇, tspan = zero_q(m) .+ 1e-2, zero_q̇(m), 5.0\nsol = solve(get_ode_problem(new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY, q, q̇, tspan))\nanimate_robot_odesolution(fig, sol, kcache, \"building1.mp4\")\nnothing","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"(Image: )","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"We will now also add some damping to each joint, otherwise our system is undamped and will never settle. For this we use the JointSubspace coordinate type to define a coordinate for each joint. The configuration of the JointSubspace coordinate is the extension of a prismatic joint, or the angle of a revolute joint.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Then we add a LinearDamper using each JointSubspace coordinate, so that we have linear damping acting on each joint.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"for i = 1:5\n    add_coordinate!(mechanism, JointSubspace(\"J$i\"); id=\"J$i\")\n    add_component!(mechanism, LinearDamper(0.5, \"J$i\"); id=\"J$(i)_damper\")\nend","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"fig = Figure(size=(854, 480))\nls = LScene(fig[1, 1]; show_axis=false)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\nrobotsketch!(ls, kcache; linewidth=2.0)\nq, q̇, tspan = zero_q(m) .+ 1e-2, zero_q̇(m), 5.0\nsol = solve(get_ode_problem(new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY, q, q̇, tspan))\nanimate_robot_odesolution(fig, sol, kcache, \"building2.mp4\")\nnothing","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"(Image: )","category":"page"},{"location":"tutorials/building/#Gravity-compensation","page":"Building a mechanism","title":"Gravity compensation","text":"","category":"section"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"First we will add gravity compensation. Gravity compensation works by applying a constant force equal to the weight of each link at its centre of mass. This is made easy by the  GravityCompensator component, and the add_gravity_compensation!.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"add_gravity_compensation!(mechanism, VMRobotControl.DEFAULT_GRAVITY)","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"note: Note\nFor gravity compensation, you should typically add the component to the virtual mechanism system, as when using control_step!, all components on the robot are treated as part of the robot model, not part of the controller, so forces due to them are not applied by the controller. ","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"fig = Figure(size=(854, 480))\nls = LScene(fig[1, 1]; show_axis=false)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\nrobotsketch!(ls, kcache; linewidth=2.0)\nq, q̇, tspan = zero_q(m) .+ 1e-2, zero_q̇(m), 5.0\nsol = solve(get_ode_problem(new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY, q, q̇, tspan))\nanimate_robot_odesolution(fig, sol, kcache, \"building3.mp4\")\nnothing","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"(Image: )","category":"page"},{"location":"tutorials/building/#End-effector-impedance-control","page":"Building a mechanism","title":"End effector impedance control","text":"","category":"section"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Finally we will add a linear spring and damper between the end-effector and a reference position. First we define a coordinate for the end-effector position","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"refpos = -0.5*X + -0.5*Y + 0.5*Z\nadd_coordinate!(mechanism, FrameOrigin(F_EE); id=\"ee_position\")\nadd_coordinate!(mechanism, ConstCoord(refpos); id=\"ref\")\nadd_coordinate!(mechanism, CoordDifference(\"ee_position\", \"ref\"); id=\"ee_error\")\n\nee_stiffness = SMatrix{3, 3}(100.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0, 0.0, 100.0)\nee_damping = SMatrix{3, 3}(5.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 5.0)\n\nadd_component!(mechanism, LinearSpring(ee_stiffness, \"ee_error\"); id=\"ee_spring\")\nadd_component!(mechanism, LinearDamper(ee_damping, \"ee_error\"); id=\"ee_damper\")","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"Note that the same LinearDamper type is used here as for the joint damping. This is because the  coordinate system handles all the geometry! As long as the damping coefficient can multiply the  velocity, the LinearDamper will work, so we can use a 3x3 matrix as shown here, or a scalar as done for joint damping.","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"fig = Figure(size=(854, 480))\nls = LScene(fig[1, 1]; show_axis=false)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\nrobotsketch!(ls, kcache; linewidth=2.0)\n\nscatter!(ls, refpos; color=:red, markersize=10)\n\nq, q̇, tspan = zero_q(m) .+ 1e-2, zero_q̇(m), 5.0\nsol = solve(get_ode_problem(new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY, q, q̇, tspan))\nanimate_robot_odesolution(fig, sol, kcache, \"building4.mp4\")\nnothing","category":"page"},{"location":"tutorials/building/","page":"Building a mechanism","title":"Building a mechanism","text":"(Image: )","category":"page"},{"location":"tutorials/control/#Virtual-Model-Control-of-a-Real-Robot-using-ROS","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"","category":"section"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"This library is not just for simulation, but can be used for realtime control of torque-controlled robots. The library aims to avoid any allocations so that it can be used in tight loops without invoking the garbage collector.","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"We provide a way to communicate over ros using the python script ./ros/rospy_client.py. This can  communicate with a julia controller using TCP/UDP sockets. ","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"To use it, run this script with python 3, providing the required command line arguments. These are the number of degrees of freedom of the robot (the length of the torque/effort vector), the name of the name of the topic to send joint torque commands to, and the name of the topic to subscribe to  joint state updates on. All command line arguments can be viewed by calling with --help.","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"The ROS interface was written and tested with the help of Yi Zhang to control the Sciurus robot.","category":"page"},{"location":"tutorials/control/#Implementing-your-own-realtime-control","page":"Virtual Model Control of a Real Robot using ROS","title":"Implementing your own realtime control","text":"","category":"section"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"The library provides an interface for realtime control via the two methods:","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"new_control_cache and\ncontrol_step!","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"New control cache creates a cache bundle: a structure containing the mechanism and a cache for  storing intermediate computations.","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"The step function should be called once per loop, and needs to be provided with the current state: the time t, joint configurations q, and joint velocities q̇. Then the effect of the virtual mechanism system is applied in two steps:","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"The virtual mechanism advances in time to t (by taking one euler step)\nThe new demanded robot torques are returned","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"Any component added to the robot is treated as part of the model of the robot, not as part of the  controller. Therefore, any component added directly to the robot is ignored by control_step! and  does not generate any forces/torques. If you wish to create a components that acts upon the robot, it must be added to the  VirtualMechanismSystem and may use coordinates from the robot by prefixing the id with \".robot.\".","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"For example, if I have a robot with coordinate \"tip_error\", I can create a spring using coordinate \"tip_error\" by using \".robot.tip_error\":","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"vms = VirtualMechanismSystem(\"MyVMS\", robot, virtual_mechanism)\nspring = LinearSpring(1000.0, \".robot.tip_error\")\nadd_component!(vms, spring; id=\"Tip spring\")","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"If instead I did","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"spring = LinearSpring(1000.0, \"tip_error\")\nadd_component!(robot, spring; id=\"Tip spring\")\nvms = VirtualMechanismSystem(\"MyVMS\", robot, virtual_mechanism)","category":"page"},{"location":"tutorials/control/","page":"Virtual Model Control of a Real Robot using ROS","title":"Virtual Model Control of a Real Robot using ROS","text":"then the controller will not apply a force due to the spring, because it thinks the spring already  exists and is part of the actual robot.","category":"page"},{"location":"examples/sciurus_reaching/#Reaching-with-Obstacle-Avoidance","page":"Sciurus reaching with obstacle avoidance","title":"Reaching with Obstacle Avoidance","text":"","category":"section"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"In this example, we will generate a controller for the sciurus17 robot to reach two targets while  avoiding two obstacles. The reaching controller will be a saturating-spring, linear-damper virtual mechanism, with additional repulsive springs to avoid the obstacles.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"The sciurus17 robot is a many-DOF robot 2 arms, a pivotting waist and 2DOF neck/head.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"using DifferentialEquations\nusing GLMakie\nusing StaticArrays\nusing VMRobotControl","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"First, we load the URDF file for the sciurus17 robot, with warnings suppressed, as the URDF file contains some features that are not supported by the URDFParser, but are not necessary for this example. We then add joint limit springs to the robot, to prevent the robot from reaching its joint limits. These act like `buffers' around the joint limits, which will and push back with a spring force as the joint approaches its limits. We also add a linear damper to each joint to make the simulation more realistic, so that the robot does not oscillate indefinitely. Finally, we add the TCPs for the left and right arms of the robot, which will be used for the reaching controller.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"cfg = URDFParserConfig(; suppress_warnings=true)\nmodule_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])\nrobot = parseURDF(joinpath(module_path, \"URDFs/sciurus17_description/urdf/sciurus17.urdf\"), cfg)","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"21DOF Mechanism{Float64} \"sciurus17\" with 27 frames, 26 joints, 44 coordinates, 74 components","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"Add joint limit springs","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"joint_limits = cfg.joint_limits\nfor joint_id in keys(joints(robot))\n    limits = joint_limits[joint_id]\n    isnothing(limits) && continue\n    add_coordinate!(robot, JointSubspace(joint_id);  id=\"$(joint_id)_coord\")\n    @assert ~isnothing(limits.lower) && ~isnothing(limits.upper)\n    add_deadzone_springs!(robot, 50.0, (limits.lower+0.1, limits.upper-0.1), \"$(joint_id)_coord\")\n    add_component!(robot, LinearDamper(0.01, \"$(joint_id)_coord\"); id=\"$(joint_id)_damper\")\nend\nadd_coordinate!(robot, FramePoint(\"l_link7\", SVector(0.,  0.08, 0.0)); id=\"L TCP\")\nadd_coordinate!(robot, FramePoint(\"r_link7\", SVector(0., -0.08, 0.0)); id=\"R TCP\")","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"\"R TCP\"","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"Next we build the virtual mechanism controller. There is no virtual mechanism structure, as the controller we are building does not require any simulated links or joints, only springs/dampers and repulsive springs. We define two targets for the robot to reach, and the position error for each target. On top of these coordinates, we add a saturating spring-damper component, which will act as the reaching controller.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"vms = VirtualMechanismSystem(\"sciurus_reaching\", robot)\nadd_gravity_compensation!(vms, VMRobotControl.DEFAULT_GRAVITY)\nvm = vms.virtual_mechanism\nadd_coordinate!(vm, ReferenceCoord(Ref(SVector(0.5,  0.0, 0.4))); id=\"target_1_pos\")\nadd_coordinate!(vm, ReferenceCoord(Ref(SVector(0.5, -0.1, 0.2))); id=\"target_2_pos\")\nadd_coordinate!(vms, CoordDifference(\".robot.L TCP\", \".virtual_mechanism.target_1_pos\"); id=\"L pos error\")\nadd_coordinate!(vms, CoordDifference(\".robot.R TCP\", \".virtual_mechanism.target_2_pos\"); id=\"R pos error\")\n\nadd_component!(vms, TanhSpring(\"L pos error\"; max_force=10.0, stiffness=1000.0); id=\"L spring\")\nadd_component!(vms, LinearDamper(10.0, \"L pos error\"); id=\"L damper\")\nadd_component!(vms, TanhSpring(\"R pos error\"; max_force=10.0, stiffness=1000.0); id=\"R spring\")\nadd_component!(vms, LinearDamper(10.0, \"R pos error\"); id=\"R damper\")","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"\"R damper\"","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"We define two obstacle positions, and for each frame in each arm attach a repulsive spring between the frame origin and the obstacle position. The repulsive spring will push the frame origin away from the obstacle, with a force that decreases as the frame origin moves away from the obstacle, according to the Gaussian potential energy of the spring.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"obstacles = Dict(\n    \"obstacle_1\" => SVector(0.4,  0.1, 0.3),\n    \"obstacle_2\" => SVector(0.3, -0.2, 0.1)\n)\ncollision_frames = String[]\nfor i in 1:7\n    push!(collision_frames, \"l_link$i\")\n    push!(collision_frames, \"r_link$i\")\nend\nfor (id, pos) in obstacles\n    add_coordinate!(vm, FramePoint(\"root_frame\", pos); id)\nend\nfor id in collision_frames\n    add_coordinate!(robot, FrameOrigin(\"$id\"); id=\"$id frame origin\")\n    for obstacle in keys(obstacles)\n        add_coordinate!(vms, CoordDifference(\".robot.$id frame origin\", \".virtual_mechanism.$obstacle\"); id=\"$obstacle $id error\")\n        add_component!(vms, GaussianSpring(\"$obstacle $id error\"; max_force=-10.0, width=0.05); id=\"$obstacle $id spring\")\n    end\nend","category":"page"},{"location":"examples/sciurus_reaching/#Setup-simulation","page":"Sciurus reaching with obstacle avoidance","title":"Setup simulation","text":"","category":"section"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"We define functions to move the targets in a circular motion, and to set the target positions and velocities in the f_control function. We then define the f_setup function to get the coordinate IDs of the target positions and velocities, to be used in the f_control function.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"We then define the timespan, initial joint angles, joint velocities, and gravity vector for the simulation. We create a dynamics cache, and an ODE problem, and solve the ODE problem using the Tsit5 solver from DifferentialEquations.jl.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"target_1_pos(t) = SVector(0.5,  0.0, 0.3) + SVector(0.2*cos(t), 0.0, 0.2*sin(t))\ntarget_1_vel(t) = SVector(-0.2*sin(t), 0.0, 0.2*cos(t))\ntarget_2_pos(t) = SVector(0.5, -0.1, 0.2) + SVector(0.0, 0.2*sin(t), 0.2*cos(t))\ntarget_2_vel(t) = SVector(0.2*cos(t), 0.0, -0.2*sin(t))\nfunction f_setup(cache)\n    id1 = get_compiled_coordID(cache, \".virtual_mechanism.target_1_pos\")\n    id2 = get_compiled_coordID(cache, \".virtual_mechanism.target_2_pos\")\n    val1 = cache[id1].coord_data.val\n    val2 = cache[id2].coord_data.val\n    vel1 = cache[id1].coord_data.vel\n    vel2 = cache[id2].coord_data.vel\n    (val1, val2, vel1, vel2)\nend\nfunction f_control(cache, t, args, extra)\n    (val1, val2, vel1, vel2) = args\n    val1[] = target_1_pos(t)\n    vel1[] = target_1_vel(t)\n    val2[] = target_2_pos(t)\n    vel2[] = target_2_vel(t)\n    false\nend\ntspan = (0., 6π)\ndcache = new_dynamics_cache(compile(vms))\nq = zero_q(dcache.vms)\nq̇ = zero_q̇(dcache.vms)\ng = VMRobotControl.DEFAULT_GRAVITY\nprob = get_ode_problem(dcache, g, q, q̇, tspan; f_setup, f_control)\n@info \"Simulating Sciurus reaching with obstacle avoidance problem.\"\nsol = solve(prob, Tsit5(); maxiters=1e5, abstol=1e-3, reltol=1e-3); # Low tol to speed up simulation","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"[ Info: Simulating Sciurus reaching with obstacle avoidance problem.\n","category":"page"},{"location":"examples/sciurus_reaching/#Plotting","page":"Sciurus reaching with obstacle avoidance","title":"Plotting","text":"","category":"section"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"We create a figure with two scenes, for two different camera angles. We plot the robot, the targets, the TCPs, and the obstacles in the scene. We use observables for the time and the kinematics cache, which will be updated in the function animate_robot_odesolution, causing any plots that depend upon these observables to be updated.","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"fig = Figure(; size = (2*720, 720), figure_padding=1.5, fontsize=32)\ndisplay(fig)\nlscenes = (LScene(fig[1, 1]; show_axis=false), LScene(fig[1, 2]; show_axis=false))\ncams = map(ls -> cam3d!(ls; center=false), lscenes)\nplotting_t = Observable(0.0)\nplotting_kcache = Observable(new_kinematics_cache(compile(vms)))\n\ntarget_scatter_kwargs = (;\n    color=:green,\n    marker=:+,\n    markersize=15,\n    label=\"Targets\",\n    transparency=true ## Avoid ugly white outline artefact on markers\n)\ntcp_scatter_kwargs = (;\n    color=:blue,\n    marker=:x,\n    markersize=15,\n    label=\"TCPs\",\n    transparency=true ## Avoid ugly white outline artefact on markers\n)\n\nfor ls in lscenes\n    # Show robot\n    robotvisualize!(ls, plotting_kcache; overdraw=false)\n\n    # Label target and TCP\n    target_1_pos_id = get_compiled_coordID(plotting_kcache[], \".virtual_mechanism.target_1_pos\")\n    target_2_pos_id = get_compiled_coordID(plotting_kcache[], \".virtual_mechanism.target_2_pos\")\n    l_tcp_pos_id = get_compiled_coordID(plotting_kcache[], \".robot.L TCP\")\n    r_tcp_pos_id = get_compiled_coordID(plotting_kcache[], \".robot.R TCP\")\n    scatter!(ls, plotting_kcache, [target_1_pos_id, target_2_pos_id]; target_scatter_kwargs...)\n    scatter!(ls, plotting_kcache, [l_tcp_pos_id, r_tcp_pos_id]; tcp_scatter_kwargs...)\n    for (id, pos) in obstacles ## Show obstacles\n        small_sphere = Sphere(Point3f(pos...), 0.05)\n        large_sphere = Sphere(Point3f(pos...), 0.1)\n        mesh!(ls, small_sphere; color=:magenta, transparency=true)\n        poly!(ls, Point3f[]; color=:magenta, label=\"Obstacles\") ## Just for legend entry\n        mesh!(ls, large_sphere; color=:cyan, alpha=0.1, transparency=true)\n        poly!(ls, Point3f[]; color=:cyan, label=\"Repulsive field\") ## Just for legend entry\n    end\nend\ncams[1].lookat[] = [0., 0., 0.3]\ncams[1].eyeposition[] = [1.5, 0., 0.3]\ncams[2].lookat[] = [0.4, 0, 0.3]\ncams[2].eyeposition[] = [0.4, 1.5, 0.3]\n\nleg = Legend(fig[1, 1], lscenes[1]; merge=true, tellwidth=false, halign=:left, valign=:top)\nsavepath = joinpath(module_path, \"docs/src/assets/sciurus_reaching.mp4\")\nanimate_robot_odesolution(fig, sol, plotting_kcache, savepath; t=plotting_t, f_setup, f_control, fastforward=1.0, fps=20);","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"<video controls width=\"100%\" height=\"auto\" autoplay loop>\n<source src=\"../../assets/sciurus_reaching.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"","category":"page"},{"location":"examples/sciurus_reaching/","page":"Sciurus reaching with obstacle avoidance","title":"Sciurus reaching with obstacle avoidance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/rail_robot/#Rail-Robot","page":"Pendulum on a Bezier-Spline Rail","title":"Rail Robot","text":"","category":"section"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"This example demonstrates a simple rail robot with a Rail joint and a Revolute joint. The resulting robot is a pendulum that can slide along a curved path.","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"using\n    DifferentialEquations,\n    GLMakie,\n    Random,\n    StaticArrays,\n    VMRobotControl\nusing VMRobotControl.Splines: CubicSpline","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"We use a cubic spline to define the path of the rail robot, and build the mechanism from a Rail joint, a Revolute joint, and a Rigid joint.","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"spline_knots = [\n    -1.0  0.0  0.1;\n    -0.5  0.0  0.0;\n    -0.0  0.0  0.1;\n    0.5  0.0  0.0;\n    1.0  0.0  0.1\n]\nspline = CubicSpline(spline_knots)\n\nT1 = Transform(SVector(0.0, 0.0, 1.0), zero(Rotor{Float64}))\nJ1 = Rail(spline, T1)\n\nT2 = Transform(SVector(0.0, 0.0, 0.0), zero(Rotor{Float64}))\nJ2 = Revolute(SVector(0.0, 1.0, 0.0), T2)\n\nT3 = Transform(SVector(0.0, 0.0, 1.0), zero(Rotor{Float64}))\nJ3 = Rigid(T3)\n\nmech = Mechanism{Float64}(\"2Link\")\ncart_frame = add_frame!(mech, \"Cart\")\nL2_frame = add_frame!(mech, \"L2\")\nEE_frame = add_frame!(mech, \"EE\")\n\nadd_joint!(mech, J1; parent=\"root_frame\",   child=cart_frame,               id=\"J1\")\nadd_joint!(mech, J2; parent=cart_frame,     child=L2_frame,                 id=\"J2\")\nadd_joint!(mech, J3, parent=L2_frame,       child=EE_frame;                 id=\"J3\")","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"\"J3\"","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"Then, we add a coordinate to the mechanism to represent the tip of the pendulum, and a coordinate to represent the position of the cart. These are used to add point masses to the mechanism.","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"add_coordinate!(mech, FrameOrigin(EE_frame);                                id=\"tip_pos\")\nadd_coordinate!(mech, FrameOrigin(cart_frame);                              id=\"cart_pos\")\nadd_component!(mech, PointMass(1.0, \"cart_pos\");                            id=\"cart_mass\")\nadd_component!(mech, PointMass(1.0, \"tip_pos\");                             id=\"pendulum_mass\")","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"\"pendulum_mass\"","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"We compile the mechanism, and setup an ODE problem to simulate the dynamics of the rail robot.","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"m = compile(mech)\n\nrng = MersenneTwister(1234)\nsol, q, q̇, T = let\n    q = [2.0 + 1e-3*randn(rng), 0.0]\n    q̇ = [0.0, 0.0]\n    T = 30\n    prob = get_ode_problem(new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY, q, q̇, T)\n    sol = solve(prob, Tsit5(), maxiters=1e4, abstol=1e-6, reltol=1e-6)\n    sol, q, q̇, T\nend;","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"Finally, we animate the solution of the ODE problem to visualize the rail robot. We will create a vector of all the tip positions of the pendulum, to animate a trail.","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"fig = Figure(; size=(720, 720), figure_padding=0)\ndisplay(fig)\nls = LScene(fig[1, 1]; show_axis=false)\ncam = cam3d!(ls; center=false)\ncam.lookat[] = [0.0, 0.0, 0.5]\ncam.eyeposition[] = [0.0, 5.0, 1.0]\nq_obs = Observable(q)\nN_trail_points = 60\ntrail_points = Observable(Vector{SVector{3, Float64}}(undef, N_trail_points))\nfill!(trail_points[], SVector{3, Float64}(NaN, NaN, NaN))\ntrail_colors = 1:N_trail_points\ntrail_width = 0.5*exp.(-LinRange(0, -3, N_trail_points))\ncache = Observable(new_kinematics_cache(m))\nrobotsketch!(ls, cache; linewidth=3)\nlines!(ls, trail_points; color=trail_colors, colormap=:viridis, linewidth=trail_width)\n\nanimate_f_setup(cache) = (get_compiled_coordID(m, \"tip_pos\"),)\nfunction animate_f_control(cache, t, args, extra)\n    tip_pos_ID = args[1]\n    pos = configuration(cache, tip_pos_ID)\n    trail_points[][1:N_trail_points-1] .= trail_points[][2:N_trail_points]\n    trail_points[][N_trail_points] = pos\n    cam.eyeposition[] = [2.0*sin(0.2*t), 5.0, 1.0]\n    update_cam!(ls.scene, cam)\n    notify(trail_points)\nend\n\n\nmodule_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])\nsavepath = joinpath(module_path, \"docs/src/assets/rail_robot.mp4\")\nanimate_robot_odesolution(fig, sol, cache, savepath; f_setup=animate_f_setup, f_control=animate_f_control);","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"[ Info: Fastforwarding animation at 2.0× speed, so that it plays in 15 seconds (was 30.0 seconds).\n","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"<video controls width=\"100%\" height=\"auto\" autoplay loop>\n<source src=\"../../assets/rail_robot.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"","category":"page"},{"location":"examples/rail_robot/","page":"Pendulum on a Bezier-Spline Rail","title":"Pendulum on a Bezier-Spline Rail","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/simulating/#Simulating-with-DifferentialEquations.jl","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"","category":"section"},{"location":"tutorials/simulating/#Getting-started","page":"Simulating with DifferentialEquations.jl","title":"Getting started","text":"","category":"section"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"To simulate the dynamics of the system, DifferentialEquations.jl can be used. The extension VMRobotControlDifferentialEquationsExt.jl is loaded when both VMRobotControl.jl and DifferentialEquation.jl are loaded.","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"using DifferentialEquations\nusing VMRobotControl\nusing StaticArrays","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"DifferentialEquations.jl expects a function with the signature f(du, u, p, t), where u is the  state, t is the current time, p is an optional vector of parameters (which we can ignore), and the answer is returned by modifying du in-place, to hold the derivative of u. The state is composed of the configurations and velocities of each joint, and the du is composed of the velocities and accelerations.","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"The function get_ode_dynamics(dynamics_cache, gravity; [f_setup, f_control]) returns a function  with the correct call signature. The dynamics cache will be mutated while simulating, so take care to avoid memory aliasing if your are multithreading. The optional functions f_setup and  f_control are called before starting and at every time step respectively.  Their type signatures can be seen by looking at the help for DEFAULT_F_SETUP and  DEFAULT_F_CONTROL.","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"get_ode_dynamics works the same way for mechanisms and virtual mechanism systems.","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"mechanism = parseRSON(\"../../../RSONs/rsons/franka_panda/pandaSurgical.rson\")\n\nm = compile(mechanism)\ndcache = new_dynamics_cache(m)\ngravity = SVector{3, Float64}(0.0, 0.0, -10.0)\n\nf_dynamics = get_ode_dynamics(dcache, gravity;)","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"Once we have the dynamics function, we can make an ODE problem, but we need to define the initial  state vector.  We can use two functions to convert between q, q̇ and a state vector u: assemble_state and state_idxs. The usage of these functions differs slightly depending on if you are working with a mechanism or virtual mechanism system, as you will have an extra configuration and velocity vector for the virtual mechanism if you are working with a virtual mechanism system.","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"q = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nq̇ = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\ntspan = 5.0\n\nu0 = assemble_state(m, q, q̇)\nprob = ODEProblem(f_dynamics, u0, tspan)\nsol = solve(prob, Tsit5())\nsol.retcode","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"Alternatively you can the step of defining f_dynamics, and use the function get_ode_problem from to do everything in one go:","category":"page"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"prob = get_ode_problem(dcache, gravity, q, q̇, tspan)\nsol = solve(prob, Tsit5())\nsol.retcode","category":"page"},{"location":"tutorials/simulating/#Using-f_setup-and-f_control","page":"Simulating with DifferentialEquations.jl","title":"Using f_setup and f_control","text":"","category":"section"},{"location":"tutorials/simulating/","page":"Simulating with DifferentialEquations.jl","title":"Simulating with DifferentialEquations.jl","text":"Two callbacks, f_setup and f_control can be provided when simulating. The first runs once before the simulation starts. The second runs once per step. The examples section demonstrates their use and signatures.","category":"page"},{"location":"tutorials/plotting/#Plotting-with-Makie","page":"Plotting with Makie.jl","title":"Plotting with Makie","text":"","category":"section"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"In this tutorial, we will demonstrate how to plot the robot using  GLMakie. Some familiarity with the Makie plotting ecosystem is required.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"The code supporting plotting with Makie is defined in the extension  \"./ext/VMRobotControlMakieExt.jl\", and where you should look if you are trying anything complicated!","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Here is a simple example of plotting a mechanism loaded from a URDF.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"using DifferentialEquations\nusing GLMakie\nusing VMRobotControl\nusing StaticArrays\n\nusing FileIO\nusing UUIDs\n    try FileIO.add_format(format\"DAE\", (), \".dae\", [:DigitalAssetExchangeFormatIO => UUID(\"43182933-f65b-495a-9e05-4d939cea427d\")])\ncatch e\nend\n\ncfg = URDFParserConfig(suppress_warnings=true)\nmechanism = parseURDF(\"../../../URDFs/franka_description/urdfs/fr3.urdf\", cfg)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\n\n# Setup the figure\nfig1 = Figure(size=(700, 350))\nls1 = LScene(fig1[1, 1]; show_axis=false)\nls2 = LScene(fig1[1, 2]; show_axis=false)\n\n# Plot the robot's visuals\nrobotvisualize!(ls1, kcache)\n# Or a sketch of it's kinematic structure\nrobotsketch!(ls2, kcache; scale=0.3, linewidth=2.5, transparency=true)\n\nsave(\"robotplot1.png\", fig1)","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"(Image: )","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"robotvisualize is used to show visual components, whereas robotsketch creates a line-sketch based upon the joints of the robot.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"This uses the Observable interface favoured by Makie, which means that when the cache is notified of a change (which can be done manually with notify), the plot is automatically updated. Here, we change the contents of the kinematics cache and notify, causing the plot to change:","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"t = 0.0\nq = Float64[0.0, 0.0, 0.0, -pi/2, pi/2, pi/2, 0.0]\nkinematics!(kcache[], t, q)\nnotify(kcache)\nsave(\"robotplot2.png\", fig1)","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"(Image: )","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"CompiledFrameIDs and certain CompiledCoordIDs can be used to plot. Plotting a frame IDs are  converted to points at the origin of the frame, and suitable coord IDs are converted to one or more points in the root frame of the mechanism. For example:","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"coord_id = get_compiled_coordID(m, \"fr3_link5_mass_coord\")\nframe_id = get_compiled_frameID(m, \"fr3_link8\")\n\nscatter!(ls2, kcache,  [coord_id, frame_id]; color=:red, markersize=10)\ntext!(ls2, kcache, [coord_id, frame_id]; text=[\"link 7 centre of mass\", \"link 8 origin\"], color=:blue)\nsave(\"robotplot3.png\", fig1)","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"(Image: )","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"There is also support for animating ODESolutions from DifferentialEquations.jl. This is via the function animate_robot_odesolution. For details of performing a simulation, read the simulation tutorial.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"To do an animation, you simply need to create a plot using an Observable of the kinematics  cache. The function animate_robot_odesolution will update the configuration of the mechanism based upon the state of the ODE solution, and notify the kinematics cache, and all of the plots you  have created will update.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"q̇ = zero_q̇(m)\nT = 3.0\n\ndcache = new_dynamics_cache(m)\ng = VMRobotControl.DEFAULT_GRAVITY\nprob = get_ode_problem(dcache, g, q, q̇, T)\nsol = solve(prob, Tsit5(), abstol=1e-10, reltol=1e-10)\n\nfps = 60\nN_frames = Int(floor(fps*T))\nts = LinRange(0.0, T, N_frames)\nanimate_robot_odesolution(fig1, sol, kcache, \"robot_animation.mp4\")","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"(Image: )","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Makie supports timeseries plots of ode-solution states directly. We can also use the sol(t) interface to access the state at a particular time and compute values, such as the stored energy. This is demonstrated  below.","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"function energy(t)\n    s = sol(t)\n    q_idxs, q̇_idxs = state_idxs(m)\n    q, q̇ = s[q_idxs], s[q̇_idxs]\n    u = zero_u(m)\n    dynamics!(dcache, t, q, q̇, g, u)\n    stored_energy(dcache)\nend\nts = LinRange(0, T, 100)\n\nfig2 = Figure()\nax = Axis(fig2[1, 1])\nl1 = lines!(ax, sol)\nl2 = lines!(ax, ts, energy.(ts), label=\"energy\"; color=:black, linewidth=3.0)\nLegend(fig2[1, 2], ax;)\nsave(\"energy_plot.png\", fig2)","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"(Image: )","category":"page"},{"location":"tutorials/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"As the mechanism we loaded has no dissipation components, only modelling point masses and inertias, the total stored energy is constant. This is a useful check to see if the implementation of you dynamics is correct!","category":"page"},{"location":"developer/developer/#Additional-info-for-Developers","page":"Developer Notes","title":"Additional info for Developers","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Pages= [\"developer/developer.md]\"","category":"page"},{"location":"developer/developer/#Testing","page":"Developer Notes","title":"Testing","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"To test, navigate to the folder \"VMRobotControl.jl\", hit \"]\" to enter the Pkg context, and run","category":"page"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"test","category":"page"},{"location":"developer/developer/#Kinematics-computations","page":"Developer Notes","title":"Kinematics computations","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"VMRobotControl.RBTree\nVMRobotControl.joint_relative_transform\nVMRobotControl.joint_relative_twist\nVMRobotControl.child_frame_twist\nVMRobotControl.joint_relative_vpa\nVMRobotControl.joint_relative_acceleration\nVMRobotControl.autodiff_jacobian_column\nVMRobotControl.child_rbstate","category":"page"},{"location":"developer/developer/#VMRobotControl.RBTree","page":"Developer Notes","title":"VMRobotControl.RBTree","text":"RBTree(m:Mechanism)\n\nFundamental data structure behind efficient kinematics computations. Used to  store caches for computations, and information about compiled frames/joints/coordinates\n\nStrategy:\n\nThere are a few things to do when going from a Mechanism to an CompiledMechanism.  The first is to change all frames from being referenced by strings to being referenced  by indexes (of type Int). This is done using the reassign_frames function for  coordinates/components and in the constructor for joints.\nThe second is to change references to joints from strings of the joints name to a suitable alternative, like a compiled joint ID, as the size of the joint-configuration vector  q must be able to be determined by the type of the ID in order to know it's size at compile time. This is done using the reassign_joints\nThe next is to create a type stable way to compute the extended kinematics (transforms,  twists and velocity product accelerations of each frame), and the jacobians of each frame.  This is accomplished by building a type-agnostic cache for each, and creating a Walk of  the rigid body tree.  The walk is simply a concrete order in which to compute and apply  joint transformation. For example, the tree with frames (1, 2, 3, 4), and structure:   1 -> 2 -> 3    -> 4     Could have a walk [(1, 2), (2, 3), (1, 4)], or equivalently [(1, 2), (1, 4), (2, 3)], or  [(1, 4), (1, 2), (2, 3)]. The important fact is that a transform earlier in the tree is  always computed before a transform later in the tree.\nEach different joint type requires different methods, we create a joint_collection  which has a field for each different joint type. This allows us to use  map or foreach to efficiently dispatch to joints to compute relative  transforms/twists/vpas, and then we use the walk to accumulate the effect of each. This works because despite each joint being a different type, the output of map or foreach is a the same.\nFor coordinates, a different approach is needed to store the dependency order. First we determine a suitable TypeStableCollection type for the collection of all coordinates,  then we create a directed graph of dependencies between coordinates. We then topologically sort the graph to determine the order in which to compute the coordinates. This is done by first computing the depth of each coordinate, and then creating a vector of vectors  where each inner vector is a set of coordinates that can be computed simultaneously, as they do not depend on each other.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.joint_relative_transform","page":"Developer Notes","title":"VMRobotControl.joint_relative_transform","text":"joint_relative_transform(joint, t, q)\n\nReturns the transform from the child frame to the parent frame of a joint configuration  and time.\n\nThe transform is represented as a Transform object\n\nq is the joint configuration for the individual joint (i.e. not for the whole mechanism) as an SVector of the appropriate size.\n\nThis function is used to ensure correct type signature for all joints and arguments, while  implementation for each AbstractJointData is done in a method of  joint_relative_transform.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.joint_relative_twist","page":"Developer Notes","title":"VMRobotControl.joint_relative_twist","text":"joint_relative_twist(joint, t, q, q̇)\n\nReturns the twist of the child frame of a joint represented in the parent frame.\n\nThe twist is represented as a Twist object. \n\nq is the joint configuration for the individual joint (i.e. not for the whole mechanism) as an SVector of the appropriate size.\n\nq̇ is the joint velocity for the individual joint (i.e. not for the whole mechanism) as an SVector of the appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.child_frame_twist","page":"Developer Notes","title":"VMRobotControl.child_frame_twist","text":"child_frame_twist(tf_parent, tf_child, twist_parent, joint_relative_twist)\n\nCompute the twist of the child frame, from the twist of the parent frame, the transforms (from each frame to the world frame) and the joint relative twist:  i.e. the twist of the child frame represented in the parent frame.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.joint_relative_vpa","page":"Developer Notes","title":"VMRobotControl.joint_relative_vpa","text":"joint_relative_vpa(joint, t, q, q̇)\n\nReturns the velocity-product-acceleration of the child frame of a joint represented in the parent frame.\n\nThe function joint_vpa applies the correction due to velocity of the parent frame.\n\nThe acceleration is represented as a SpatialAcceleration object\n\nMost joint types have no velocity-product-acceleration, and return zero. \n\nWhat is velocity-product-acceleration?\n\nVelocity product acceleration is the acceleration of the child frame relative to the parent frame due to the velocity of the joint variable, q̇, assuming  q̈=0, and that the parent frame is stationary. As an example, consider the linear velocity as ȯ = J(q)q̇, then the derivative with time is  ö = J(q)q̈ + J̇(q)q̇. Here J(q) is the jacobian of the joint. Thus J̇(q) ̇q is the  velocity product acceleration.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.joint_relative_acceleration","page":"Developer Notes","title":"VMRobotControl.joint_relative_acceleration","text":"joint_relative_acceleration(joint, q, q̈, t)\n\nReturns the acceleration of the child frame relative to the parent frame due to the acceleration of the joint variable, q̈.\n\nDoes NOT include velocity-product-accelerations terms like centrifugal/coriolis acceleration.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.autodiff_jacobian_column","page":"Developer Notes","title":"VMRobotControl.autodiff_jacobian_column","text":"autodiff_jacobian_column(joint1dof, tf_parent, tf_child, tf_final, qi)\n\nUsed to efficiently compute jacobians using automatic differentiation.\n\nUses precomputed transforms to compute the derivative of a final transform  tf_final w.r.t. a single joint config, qi, by using knowledge that the other  transforms are not a function of qi\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.child_rbstate","page":"Developer Notes","title":"VMRobotControl.child_rbstate","text":"child_rbstate(state_parent, state_relative)\n\nComputes the rigid body state of a child from from the parent state, and the  relative state. state_parent is the state of the parent rigid body (transform, twist, vpa). state_relative contains the relative transform/twist/vpa between the child  frame and parent frame.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#TypeStableCollection","page":"Developer Notes","title":"TypeStableCollection","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Let me illustrate the challenge: you have a robot with a mix of types of joint:  revolute, prismatic and potentially other types too. You want to write a function that can take any such robot and compute its kinematics. If you simply make a list of joints, then it will not be concretely typed (e.g. `Vector{Any}. It is  possible that small union optimisations would work for this example, but that doesn't scale to the  number of different coordinate types or component types.)","category":"page"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Instead, we could use a tuple of the joints, but this would mean a different type for the robot for  every arrangement of joints. Instead we use a tuple of vectors: one vector for each different type. This means that any robot made of only revolute and prismatic joints will be of the same type! We store the order of computation separately, by storing indices into the tuple of vectors.","category":"page"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"The tuple-of-vectors structure is called a TypeStableCollection and has drawn inspiration  from TypeSortedCollection, but has some difference in construction and indexing.","category":"page"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Modules = [VMRobotControl.TypeStableCollections,]","category":"page"},{"location":"developer/developer/#VMRobotControl.TypeStableCollections.TypeStableCollection","page":"Developer Notes","title":"VMRobotControl.TypeStableCollections.TypeStableCollection","text":"TypeStableCollection{TUPTYPE}\n\nA collection of vectors, where each vector has a different element type. The element types are stored in a tuple of type TUPTYPE.\n\nAllows for type stable operations on the collection, such as map, mapreduce, foreach.\n\nCan be built using the extend function to add new/existing types and return an index; [push!] to add types already present; or push_return_index! to add types already present and return the index of the newly added element.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.TypeStableCollections.TypeStableCollection-Tuple{}","page":"Developer Notes","title":"VMRobotControl.TypeStableCollections.TypeStableCollection","text":"TypeStableCollection()\n\nCreate an empty TypeStableCollection, useful to then use extend.\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.TypeStableCollections.TypeStableIdx","page":"Developer Notes","title":"VMRobotControl.TypeStableCollections.TypeStableIdx","text":"TypeStableIdx{T}\n\nAn index into a TypeStableCollection.\n\nThe index is parameterized by the type of the element it points to, T. Therefore it  can still be used to access an extended collection, even if the type of the collection  has changed, or if elements have been appended to the collection.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.TypeStableCollections.extend-Union{Tuple{T}, Tuple{TUPTYPE}, Tuple{VMRobotControl.TypeStableCollections.TypeStableCollection{TUPTYPE}, T}} where {TUPTYPE, T}","page":"Developer Notes","title":"VMRobotControl.TypeStableCollections.extend","text":"extend(c::TypeStableCollection, val)\n\nExtend the type stable collection by adding val. If the type of val is already in the collection, val is appended to the corresponding vector. If the type is not already in the collection, a new vector is created, thus changing the type of the collection.\n\nAs a result, the type of the collection may change after calling extend. Therefore, to keep the calling code type stable, it is recommended to always  name the return value of extend with a new variable, and use that variable in  subsequent code.\n\nReturns: the new collection and a TypeStableIdx to the newly added value. \n\nExamples\n\njulia> c1 = TypeStableCollection(())\nTypeStableCollection{Tuple{}}(())\njulia> c2, idx = extend(c1, 2)\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.TypeStableCollections.push_return_index!-Union{Tuple{T}, Tuple{TUPTYPE}, Tuple{VMRobotControl.TypeStableCollections.TypeStableCollection{TUPTYPE}, T}} where {TUPTYPE, T}","page":"Developer Notes","title":"VMRobotControl.TypeStableCollections.push_return_index!","text":"push_return_index!(c::TypeStableCollection, val)\n\nPush val to the collection c. Requires that type of val is already in the collection.\n\nReturns: the modified collection and a TypeStableIdx to the newly added value.\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#Transforms","page":"Developer Notes","title":"Transforms","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Modules = [VMRobotControl.Transforms,]","category":"page"},{"location":"developer/developer/#VMRobotControl.Transforms.EulerVector","page":"Developer Notes","title":"VMRobotControl.Transforms.EulerVector","text":"EulerVector(v::SVector{3})\n\nRepresents a rotation on the plane with normal vector v, by angle norm(v).\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Transforms.SpatialAcceleration","page":"Developer Notes","title":"VMRobotControl.Transforms.SpatialAcceleration","text":"SpatialAcceleration{T}\n\nA spatial acceleration represents the acceleration of a rigid body/frame in 3D space.\n\nIt is composed of a linear acceleration and an angular acceleration.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Transforms.Transform","page":"Developer Notes","title":"VMRobotControl.Transforms.Transform","text":"Transform{T}(origin::SVector{3, T}, rotor::Rotor{T})\n\nA rigid body transform defined by an origin and a rotor (quaternion). \n\nCan be constructed from either an origin and a rotor, or just an origin, or just a rotor.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Transforms.Twist","page":"Developer Notes","title":"VMRobotControl.Transforms.Twist","text":"Twist{T}(linear::SVector{3, T}, angular::SVector{3, T})\n\nA twist represents the velocity of a rigid body/frame in 3D space.  It is composed of a linear velocity and an angular velocity.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Transforms.AxisAngleDerivative-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Developer Notes","title":"VMRobotControl.Transforms.AxisAngleDerivative","text":"Partial derivative of rotor w.r.t. angle\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.angular_velocity_prematrix-Tuple{Rotor}","page":"Developer Notes","title":"VMRobotControl.Transforms.angular_velocity_prematrix","text":"angular_velocity_prematrix(r::Rotor)\n\nReturn S, which satisfies S*ṙ = ω, where omega is the angular velocity of the  frame.\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.angular_velocity_prematrix_derivative-Tuple{SVector{4}}","page":"Developer Notes","title":"VMRobotControl.Transforms.angular_velocity_prematrix_derivative","text":"angular_velocity_prematrix_derivative(ṙ::SVector)\n\nReturn Ṡ, time derivative of angular_velocity_prematrix(r)\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.quaternion_derivative_propagation-Tuple{Rotor}","page":"Developer Notes","title":"VMRobotControl.Transforms.quaternion_derivative_propagation","text":"quaternion_derivative_propagation(r::Rotor)\n\nReturns the matrix E which satisfies E*ω = ṙ, where ω is the angular velocity of rotor r\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.quaternion_derivative_propagation_derivative-Tuple{Rotor, SVector{3}}","page":"Developer Notes","title":"VMRobotControl.Transforms.quaternion_derivative_propagation_derivative","text":"quaternion_derivative_propagation_derivative(r::Rotor, ω)\n\nReturns the matrix Ė, time derivative of quaternion_derivative_propagation(r)\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.quatmul_geodual_bivector_matrix-Tuple{Rotor}","page":"Developer Notes","title":"VMRobotControl.Transforms.quatmul_geodual_bivector_matrix","text":"quatmul_geodual_bivector_matrix(r::Rotor)\n\nReturns a matrix S that corrects from a rotor jacobian ̇r = J⁽ʳ⁾q to an angular velocity jacobian ω = J⁽ʷ⁾̇q, by J⁽ʷ⁾ = S J⁽ʳ⁾.\n\nEquivalent to performing quaternion multiplication with, flipping the direction  of the vector and extracting the vector part of the result....\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#VMRobotControl.Transforms.skew-Union{Tuple{SVector{3, T}}, Tuple{T}} where T","page":"Developer Notes","title":"VMRobotControl.Transforms.skew","text":"skew(v::SVector{3})\n\nReturn the skew symettric matrix operator performing vector product.\n\n\n\n\n\n","category":"method"},{"location":"developer/developer/#Other-API-documentation","page":"Developer Notes","title":"Other API documentation","text":"","category":"section"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"Here are the remaining docs not included in the main API","category":"page"},{"location":"developer/developer/","page":"Developer Notes","title":"Developer Notes","text":"VMRobotControl.CompiledMechanism\nVMRobotControl.CompiledVirtualMechanismSystem\nVMRobotControl.CompiledCoordID\nVMRobotControl.reassign_coords\nVMRobotControl.GenericComponent\nVMRobotControl.Splines.curve_derivative\nVMRobotControl.Splines.curve_second_derivative\nVMRobotControl.ComponentData\nVMRobotControl.frame_ancestor_matrix\nVMRobotControl.reassign_joints\nVMRobotControl.TimeFuncJoint\nVMRobotControl._construct_coordinate_graph\nVMRobotControl.URDF.parseURDFString\nVMRobotControl.RSON.parseRSONString\nVMRobotControl.RSON.parseRSONVersion\nVMRobotControl.AbstractJointData\nVMRobotControl.Spherical\nVMRobotControl.Inertance\nVMRobotControl.rigid_joint_twist\nVMRobotControl._add_jacobian_transpose_times_force!\nVMRobotControl._add_opspace_force!\nVMRobotControl.jacobian_column\nVMRobotControl.state_idxs\nVMRobotControl.remake\nVMRobotControl.reassign_frames\nVMRobotControl.MechanismJoint\nVMRobotControl.Splines.curve_position\nVMRobotControl.EltypeCache\nVMRobotControl.Dissipation","category":"page"},{"location":"developer/developer/#VMRobotControl.CompiledMechanism","page":"Developer Notes","title":"VMRobotControl.CompiledMechanism","text":"CompiledMechanism(m::Mechanism)\n\nA compiled version of a Mechanism which is used for efficient kinematics/dynamics computations.\n\nSee also: compile, Mechanism\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.CompiledVirtualMechanismSystem","page":"Developer Notes","title":"VMRobotControl.CompiledVirtualMechanismSystem","text":"CompiledVirtualMechanismSystem{T, M1, M2, TSC1, TSC2}\n\nA compiled virtual mechanism system is a VirtualMechanismSystem that has been compiled into a form that is efficient for computations/simulation. \n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.CompiledCoordID","page":"Developer Notes","title":"VMRobotControl.CompiledCoordID","text":"CompiledCoordID{C}\n\nA unique identifier for a coordinte in a compiled mechanism/virtual mechanism system.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.reassign_coords","page":"Developer Notes","title":"VMRobotControl.reassign_coords","text":"reassign_coords(c, coord_replacement_dict)\n\nFor joint/coordinate/component c  all references to any coordinate id using the replacement dictionary.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.GenericComponent","page":"Developer Notes","title":"VMRobotControl.GenericComponent","text":"GenericComponent{T} <: ComponentData{T}\n\nSupertype for any components which do not fall cleanly into an inertance, storage or dissipation.\n\nImplement inertance_matrix!, generalized_force!, and stored_energy.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Splines.curve_derivative","page":"Developer Notes","title":"VMRobotControl.Splines.curve_derivative","text":"curve_derivative(t, ::CubicBezierCurve)\n\nFirst derivative of a cubic bezier curve at t. \n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.Splines.curve_second_derivative","page":"Developer Notes","title":"VMRobotControl.Splines.curve_second_derivative","text":"curve_second_derivative(t, ::CubicBezierCurve)\n\nSecond derivative of a cubic bezier curve at t.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.ComponentData","page":"Developer Notes","title":"VMRobotControl.ComponentData","text":"ComponentData{T}\n\nSupertype for all mechanical components with eltype T. \n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.frame_ancestor_matrix","page":"Developer Notes","title":"VMRobotControl.frame_ancestor_matrix","text":"frame_ancestor_matrix(m::Mechanism)\n\nReturns matrix B such that B[frame_1, frame_2] ⟹ frame_1 is an ancestor of frame 2 in the tree\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.reassign_joints","page":"Developer Notes","title":"VMRobotControl.reassign_joints","text":"reassign_joints(c, joint_replacement_dict)\n\nFor joint/coordinate/component c replace all references to any joint jointid with  joint_replacement_dict[jointid]. Will be recursively applied to fields of the component, such as coordinates.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.TimeFuncJoint","page":"Developer Notes","title":"VMRobotControl.TimeFuncJoint","text":"TimeFuncJoint(f_tf::Function, f_twist::Function, f_vpa::Function)\n\nA TimeFuncJoint represents a joint which has a transform which is a function of time: f_tf(t). The derivatives f_twist and f_vpa must be provided, and checked, by the user.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl._construct_coordinate_graph","page":"Developer Notes","title":"VMRobotControl._construct_coordinate_graph","text":"_construct_coordinate_graph(coordinates)\n\nConstruct a graph of coordinates dependencies on each other.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.URDF.parseURDFString","page":"Developer Notes","title":"VMRobotControl.URDF.parseURDFString","text":"parseURDFString(urdfstring::AbstractString, [cfg::URDFParserConfig])\n\nParse a Mechanism from a URDF string. If cfg is provided, the directory of the URDF file path  from the config will be used to find mesh files.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.RSON.parseRSONString","page":"Developer Notes","title":"VMRobotControl.RSON.parseRSONString","text":"parseRSONString(rsonstr::AbstractString, [rsonpath::AbstractString], [cfg::RSONParserConfig])\n\nParse a Mechanism or VirtualMechanismSystem from an RSON string. If rsonpath is not provided, it defaults to \".\", which is used for relative paths to locate associated files such as meshes for  visuals.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.RSON.parseRSONVersion","page":"Developer Notes","title":"VMRobotControl.RSON.parseRSONVersion","text":"parseRSONVersion(data, cfg)\n\nWill parse the version, and assert that it is compatible with the current parser version. The parsed version will be stored in cfg.rson_version.\n\nThe version is expected to be a string of the form \"v<major>.<minor>.<patch>\", where each part is an integer.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.AbstractJointData","page":"Developer Notes","title":"VMRobotControl.AbstractJointData","text":"AbstractJointData{T}\n\nAn instance of AbstractJointData represents the data needed to compute the  transform between two unspecified frames of reference. When added to a mechanism the frames are specified.\n\nT is the scalar type of the joint (typically Float64), and can be extracted with valuetype(::AbstractJoint).\n\nA joint can be added to a mechanism using the add_joint! function, which  requires the joint, the parent frame, and the child frame, creating a  MechanismJoint`.\n\nSee also\n\nJoint data types: Rigid, Revolute, Prismatic, Rail\n\nDeveloper Notes\n\nEach joint type must implement the following methods:\n\n_joint_relative_transform (See joint_relative_transform)\n_joint_relative_twist (See joint_relative_twist)\n_joint_relative_vpa (See joint_relative_vpa)\n_joint_relative_acceleration (See joint_relative_acceleration)\n_jacobian_columns (See jacobian_column)\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Spherical","page":"Developer Notes","title":"VMRobotControl.Spherical","text":"Spherical()\nSpherical(tf::Transform)\n\nBROKEN. DOES NOT WORK YET.\n\nRepresents a spherical joint between two frames. \n\nSee also Revolute\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.Inertance","page":"Developer Notes","title":"VMRobotControl.Inertance","text":"Inertance{T} <: ComponentData{T}\n\nSupertype for all inertance components, which store kinetic energy and induce inertances and generalized forces in the mechanism.\n\nThese components support stored_energy, inertance_matrix!, and generalized_force!, typically by implementing _stored_energy, inertance_matrix!, and _opspace_force.\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.rigid_joint_twist","page":"Developer Notes","title":"VMRobotControl.rigid_joint_twist","text":"rigid_joint_twist(tf_parent, tf_child, twist_parent)\n\nCompute the twist of the child frame from the transforms and the twist of the  parent frame. Assumes that the frames are rigidly connected.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl._add_jacobian_transpose_times_force!","page":"Developer Notes","title":"VMRobotControl._add_jacobian_transpose_times_force!","text":"_jacobian_transpose_times_force!(τ, J, F)\n\nCalculate the product of the transpose of the Jacobian J and the force F, and add it to τ.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl._add_opspace_force!","page":"Developer Notes","title":"VMRobotControl._add_opspace_force!","text":"_add_opspace_force!(cache, c::CompiledCoord)\n\nAdd opspace force f to the cache for coordinate c.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.jacobian_column","page":"Developer Notes","title":"VMRobotControl.jacobian_column","text":"jacobian_column(joint, tf_parent, tf_final, q_i)\n\nReturns the jacobian columns Jo and Jw for joint such that if all other  joints where stationary, the linear velocity of a frame with transform tf_final  would be Jo*q̇ and the angular velocity would be Jw*q̇\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.state_idxs","page":"Developer Notes","title":"VMRobotControl.state_idxs","text":"state_idxs(Σ::CompiledVirtualMechanismSystem)\n\nReturns the indices for getting the state from the ODE vector.\n\nReturns\n\nqʳidxs::UnitRange{Int} - The indices for the robot configuration qᵛidxs::UnitRange{Int} - The indices for the virtual mechanism configuration q̇ʳidxs::UnitRange{Int} - The indices for the robot velocity q̇ᵛidxs::UnitRange{Int} - The indices for the virtual mechanism velocity\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.remake","page":"Developer Notes","title":"VMRobotControl.remake","text":"remake(thing; <keyword arguments>)\n\nRe-construct thing with new field values specified by the keyword arguments. Must have a keyword-constructor.\n\nAdapted from SciMLBase\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.reassign_frames","page":"Developer Notes","title":"VMRobotControl.reassign_frames","text":"reassign_frames(c, frame_replacement_dict)\n\nFor joint/coordinate/component c replace all references to any frame with  frame_replacement_dict[frame]. Will be recursively applied to fields of the component, such as coordinates.\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.MechanismJoint","page":"Developer Notes","title":"VMRobotControl.MechanismJoint","text":"MechanismJoint(joint, parentFrameID::Int, childFrameID::Int)\n\nContains jointdata, and the IDs of parent/child frames that the joint connects.\n\nBefore a mechanism is compiled, these frame IDs are strings–-the name of the  frame–-, after compilation it is an integer, unique for each frame.\n\nSee also AbstractJointData, add_joint!\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Splines.curve_position","page":"Developer Notes","title":"VMRobotControl.Splines.curve_position","text":"curve_position(t, ::CubicBezierCurve)\n\nr(t) is a cubic bezier curve passing through p₁ and p₄ at t=0.0 and 1.0 respectively, with control points  p₂ and p₃. It is twice differentiable.\n\nExamples\n\njulia> c = CubicBezierCurve(2.1, 2.3, 2.7, 2.9)\njulia> curve_position(0.0, c)\n1-element SVector{1, Float64} with indices SOneTo(1):\n 2.1\n\n\n\n\n\n","category":"function"},{"location":"developer/developer/#VMRobotControl.EltypeCache","page":"Developer Notes","title":"VMRobotControl.EltypeCache","text":"EltypeCache{VALUETYPE, F<:Function}\n\nA cache for storing results of a function with different eltypes. For example, if a Vector{Float64}, and Vector{Float32} cache are both needed, then VALUETYPE can be Vector{T} where T and function can be (VALUETYPE, ELTYPE) -> Vector{ELTYPE}().\n\n\n\n\n\n","category":"type"},{"location":"developer/developer/#VMRobotControl.Dissipation","page":"Developer Notes","title":"VMRobotControl.Dissipation","text":"Dissipation{T} <: ComponentData{T}\n\nSupertype for all dissipative components, which cannot store energy and only dissipate it. \n\nThese components support generalized_force!, typically by implementing _opspace_force. \n\n\n\n\n\n","category":"type"},{"location":"tutorials/using/#Using-a-Mechanism","page":"Using a mechanism","title":"Using a Mechanism","text":"","category":"section"},{"location":"tutorials/using/#Compiling","page":"Using a mechanism","title":"Compiling","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"The Mechanism type is designed to be used for building the mechanism, not for performing fast computations.  Its internal data structures rely on Abstract types, which makes construction easier, but is  inherently type unstable. Once you have built your mechanism it can be \"compiled\" into a CompiledMechanism, which is fully type stable (see TypeStableCollection for more info on how this is achieved.).","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"First, we will load a mechanism: a 3 link robot defined by an RSON file.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"using VMRobotControl\nmechanism = parseRSON(\"../../../RSONs/rsons/simple3link.rson\")","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"Compiling a mechanism is as simple as ","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"m = compile(mechanism)","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"This returns the type-stable version of your mechanism. The compiled mechanism's type stable data structures can be accessed with fast indices, for example  let us consider the coordinate we added earlier for the link 3 centre of mass \"L3_com\".","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"L3_com = get_compiled_coordID(m, \"L3_com\")","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"This returns the CompiledCoordID for the coordinate. Note that VMRobotControl.CompiledCoordID  is a parametric type, so its type varies depending on the type of the coordinate. We can use this ID on the mechanism to get the compiled coordinate data:","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"m[L3_com]","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"In this case, the compiled coordinate data has replaced String frame ID \"L3_frame\" with the compiled frame ID of the compiled frame.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"L3_frame_id = get_compiled_frameID(m, \"L3_frame\")\nL3_frame_id == m[L3_com].coord_data.frameID","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"For the full API see API","category":"page"},{"location":"tutorials/using/#Caches-and-\"Cache-Bundles\"","page":"Using a mechanism","title":"Caches and \"Cache-Bundles\"","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"To use a mechanism to perform computations we need to create a cache for storing intermediate computations and results in. The cache and mechanism are normally needed together, so they are bundled together by default.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"There are several functions for creating cache-bundles for different purposes:","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"Constructor Methods Description\nnew_kinematics_cache kinematics! For transforms/coordinate configurations, used for plotting\nnew_jacobians_cache jacobians! For kinematics and jacobians\nnew_rbstates_cache velocity_kinematics!, acceleration_kinematics! For kinematics and velocities/velocity product accelerations (VPAs)\nnew_dynamics_cache velocity_kinematics!, precompute!, inertance_matrix!, generalized_force!, dynamics! For kinematics, velocities, VPAs, jacobians, and inertance matrices/generalized forces, used for simulating\nnew_control_cache control_step! For realtime control with a virtual-mechanism-system","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"For examples of using the kinematics cache for plotting skip to Plotting with Makie. For examples of using the dynamics cache for simulation skip to Simulating with DifferentialEquations.jl.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"dcache = new_dynamics_cache(m)\n\nt = 0.0\nq = zero_q(m)\nq̇ = zero_q̇(m)\ng = VMRobotControl.DEFAULT_GRAVITY\nu = zero_u(m)\ndynamics!(dcache, t, q, q̇, g, u)","category":"page"},{"location":"tutorials/using/#Accessing-results","page":"Using a mechanism","title":"Accessing results","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"There are several functions for accessing results from a cache/bundle.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"warning: Warning\nThe contents of a cache are NOT guaranteed to be initialized when it is created. Ensure you call the method needed to compute your results before accessing results from the cache.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"warning: Warning\nNote that some of these results are Vectors/Matrices from the cache, or other heap-allocated  objects, that will be updated when you use the cache again.  If you are using a result from the cache, and need to use the cache again, make sure to copy the results first!","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"As we have called dynamics!, the results in the cache are ready to view. Let's look at some of the computed values for the compiled frame ID from before.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"get_inertance_matrix(dcache)\nget_generalized_force(dcache)\nget_transform(dcache, L3_frame_id)\nget_linear_vel(dcache, L3_frame_id)\nget_angular_vel(dcache, L3_frame_id)\nget_linear_vpa(dcache, L3_frame_id)\nget_angular_vpa(dcache, L3_frame_id)\nget_linear_jacobian(dcache, L3_frame_id)\nget_angular_jacobian(dcache, L3_frame_id)","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"However, more often than not you will instead use coordinates to access positions/velocities and jacobians of interest. ","category":"page"},{"location":"tutorials/using/#Coordinate-computations","page":"Using a mechanism","title":"Coordinate computations","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"There are four functions to access computation results for coordinates: configuration, velocity, vpa, and jacobian.  As before, you must make sure the cache is populated with results before calling these functions, and copy the result elsewhere if you are then going to use the cache again.","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"configuration(dcache, L3_com)\nvelocity(dcache, L3_com)\nvpa(dcache, L3_com)\njacobian(dcache, L3_com)","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"Configuration is dependent only on the time and joint state q, so can also be used with the kinematics cache.","category":"page"},{"location":"tutorials/using/#Component-computations","page":"Using a mechanism","title":"Component computations","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"TODO","category":"page"},{"location":"tutorials/using/#Modifying-a-compiled-mechanism","page":"Using a mechanism","title":"Modifying a compiled mechanism","text":"","category":"section"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"A compiled mechanism can be modified using Base.setindex!, by modifying its joints/coordinates/components, only if the  type of the joint/component does not change.  This is made simpler by using the remake function which allows you to easily remake a compiled joint/coordinate/component and modify one or more of its fields using keyword arguments. The interface to do so is like so:","category":"page"},{"location":"tutorials/using/","page":"Using a mechanism","title":"Using a mechanism","text":"using VMRobotControl: remake\nm[ee_com] = remake(m[ee_com]; point=SVector(0.3*z))","category":"page"},{"location":"examples/compliant_path_following/#Compliant-Path-Following","page":"Franka compliant path following","title":"Compliant Path Following","text":"","category":"section"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"This example demonstrates how to simulate a compliant path following control strategy for a robot moving along a predefined path. One problem with traditional path following controllers is that the reference moves irrespective of the robot's behaviour. If an obstacle is encountered, the reference will continue to move, potentially causing the robot to exert large forces on the obstacle, and inducing large tracking errors.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"A compliant path following controller, is driven along the path of the trajectory by a virtual mechanism system, which is connected to the robot's end effector by a virtual spring and damper. Thus, if an obstacle is encountered, the connection between the robot and the virtual mechanism will stop the ``reference'' from moving, and the robot will behave compliantly. Thus compliant behaviour can be achieved along the trajectory, while still stiffly constraining the robot to the path.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"The robot is controlled by a virtual mechanism system, which includes a virtual track (trajectory) that a virtual cart moves along. A virtual spring and damper are used to connect the virtual cart to the robot's end effector, and a force source applies a driving force to the virtual cart.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"The robot is controlled to follow a predefined path while being subjected to a disturbance force. The result is a controller which stiffly constrains the robot to the path, while behaving compliantly along the direction of travel. When a force exceeding the driving force is applied to the robot, the cart may even reverse its direction of travel, but the linear spring will ensure that the robot remains on the path.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"using DifferentialEquations\nusing GLMakie\nusing LinearAlgebra\n\nusing VMRobotControl\nusing VMRobotControl.Splines: CubicSpline\nusing StaticArrays","category":"page"},{"location":"examples/compliant_path_following/#Loading/Building-the-Robot-and-Controller","page":"Franka compliant path following","title":"Loading/Building the Robot and Controller","text":"","category":"section"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"First, we define the path that the robot will follow. The path is defined as a spline, which is a piecewise cubic polynomial that interpolates a set of points. We construct the spline using a set of points that define the path, and then create a CubicSpline object from these points, which will pass exactly through the points.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Care must be taken to ensure that the path is smooth and continuous, as the units of the system state are in meters and radians: if there are large differences in scale between the points, on the path, then the automatic tolerance selection in the ODE solver may struggle to perform well, as in some regions of the path a small difference in q may cause a large difference in the position, requiring a small step size to accurately simulate the system.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"start = SVector(0.425, 0.15, 0.10)\ns_width = 4e-2\ns_length = 20e-2\nspline = let w=s_width, x0=start[1], y0=start[2], L=s_length, h=start[3], Nk = 6, Nr = 6\n    forward = Vector(LinRange(x0, x0+L, Nk))\n    backward = Vector(reverse(forward))\n    spline_points = Matrix{Float64}(undef, 0, 3);\n\n    for i = 0:(Nr-1)\n        knots = (i%2)!=1 ? forward : backward\n        spline_points = vcat(\n            spline_points,\n            hcat(knots, y0 .+ w*i*ones(size(knots)), h*ones(size(knots)))\n        )\n    end\n    CubicSpline(spline_points)\nend","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"VMRobotControl.Splines.CubicSpline{3, Float64}(VMRobotControl.Splines.CubicSplineData{3, Float64}([0.425 0.15 0.1; 0.465 0.15 0.1; 0.505 0.15 0.1; 0.545 0.15 0.1; 0.585 0.15 0.1; 0.625 0.15 0.1; 0.625 0.19 0.1; 0.585 0.19 0.1; 0.545 0.19 0.1; 0.505 0.19 0.1; 0.465 0.19 0.1; 0.425 0.19 0.1; 0.425 0.22999999999999998 0.1; 0.465 0.22999999999999998 0.1; 0.505 0.22999999999999998 0.1; 0.545 0.22999999999999998 0.1; 0.585 0.22999999999999998 0.1; 0.625 0.22999999999999998 0.1; 0.625 0.27 0.1; 0.585 0.27 0.1; 0.545 0.27 0.1; 0.505 0.27 0.1; 0.465 0.27 0.1; 0.425 0.27 0.1; 0.425 0.31 0.1; 0.465 0.31 0.1; 0.505 0.31 0.1; 0.545 0.31 0.1; 0.585 0.31 0.1; 0.625 0.31 0.1; 0.625 0.35 0.1; 0.585 0.35 0.1; 0.545 0.35 0.1; 0.505 0.35 0.1; 0.465 0.35 0.1; 0.425 0.35 0.1], [0.425 0.15 0.1; 0.4650404299101982 0.14992992148898976 0.10000000000000002; 0.5048382803592072 0.1502803140440408 0.10000000000000003; 0.545606448652973 0.148948822334847 0.1; 0.582735925028901 0.1539243966165712 0.10000000000000003; 0.6334498512314223 0.1353535911988681 0.1; 0.63346467004541 0.20466123858795626 0.10000000000000002; 0.5826914685869382 0.18600145444930694 0.1; 0.5457694556068371 0.19133294361481612 0.10000000000000002; 0.5042307089857143 0.18866677109142868 0.10000000000000002; 0.46730770845030617 0.19399997201946925 0.1; 0.4165384572130613 0.17533334083069424 0.10000000000000002; 0.4165384626974484 0.24466666465775389 0.1; 0.46730769199714484 0.22600000053829014 0.10000000000000002; 0.5042307693139725 0.23133333318908558 0.1; 0.5457692307469653 0.22866666670536728 0.10000000000000002; 0.582692307698167 0.23399999998944523 0.10000000000000002; 0.6334615384603667 0.21533333333685156 0.10000000000000002; 0.6334615384603667 0.28466666666314844 0.10000000000000002; 0.5826923076981669 0.2660000000105548 0.10000000000000002; 0.5457692307469654 0.27133333329463266 0.10000000000000002; 0.5042307693139725 0.26866666681091445 0.10000000000000002; 0.4673076919971448 0.27399999946170983 0.10000000000000002; 0.4165384626974485 0.2553333353422461 0.10000000000000002; 0.4165384572130613 0.32466665916930576 0.10000000000000002; 0.46730770845030606 0.3060000279805307 0.10000000000000002; 0.5042307089857143 0.31133322890857135 0.10000000000000002; 0.5457694556068371 0.30866705638518394 0.10000000000000002; 0.5826914685869382 0.31399854555069306 0.10000000000000002; 0.6334646700454099 0.29533876141204374 0.10000000000000002; 0.6334498512314224 0.36464640880113186 0.10000000000000002; 0.5827359250289011 0.3460756033834287 0.10000000000000002; 0.545606448652973 0.351051177665153 0.10000000000000002; 0.5048382803592073 0.3497196859559591 0.10000000000000002; 0.4650404299101983 0.35007007851101013 0.10000000000000003; 0.425 0.35 0.1]))","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Because the meshes for the franka robot are in the DAE file format, which is not natively supported by MeshIO/FileIO, we have to manually register the DAE file format to be able to load Register DAE file format to DigitalAssetExchangeFormatIO, so that the mesh files for the franka robot can be loaded. Most of the time, this is done automatically by the package that provides the file format, but in this case we have to do it manually, before we can load the URDF file. Then we load the URDF file, with warnings suppressed, as the URDF file contains some features that are not supported by the URDFParser, but are not necessary for this example.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"We then add gravity compensation to the robot model. As the franka robot does its own gravity compensation, this is considered part of the robot model, rather than part of the controller, so it is added directly to robot, not to the virtual mechanism system.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"We then define a tool center point (TCP), in the end-effector frame of the robot, and add a coordinate to the robot model to represent the TCP. We also add a coordinate to the robot model for each joint, and add a tanh damper component to each joint to make the simulation more realistic, emulating the coulomb friction in the joints. The choice of β will affect the minimum velocity at which the damper will start to act, and will therefore affect the number of timesteps required to simulate the system: a smaller β will require more timesteps.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"using FileIO, UUIDs\ntry\n    FileIO.add_format(format\"DAE\", (), \".dae\", [:DigitalAssetExchangeFormatIO => UUID(\"43182933-f65b-495a-9e05-4d939cea427d\")])\ncatch\nend\nmodule_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])\nrobot = parseRSON(joinpath(module_path, \"RSONs/rsons/franka_panda/pandaSurgical.rson\"))\nadd_gravity_compensation!(robot, VMRobotControl.DEFAULT_GRAVITY)\nadd_coordinate!(robot, FrameOrigin(\"instrument_EE_frame\"); id=\"TCP\")\n\nfor (i, τ_coulomb) in zip(1:7, [5.0, 5.0, 5.0, 5.0, 3.0, 3.0, 3.0])\n    β = 1e-1\n    add_component!(robot, TanhDamper(τ_coulomb, β, \"J$i\"); id=\"J$(i)_damper\")\nend;","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"┌ Warning: lines is not supported\n└ @ DigitalAssetExchangeFormatIO ~/.julia/packages/DigitalAssetExchangeFormatIO/JX3kq/src/parser.jl:127\n┌ Warning: lines is not supported\n└ @ DigitalAssetExchangeFormatIO ~/.julia/packages/DigitalAssetExchangeFormatIO/JX3kq/src/parser.jl:127\n┌ Warning: lines is not supported\n└ @ DigitalAssetExchangeFormatIO ~/.julia/packages/DigitalAssetExchangeFormatIO/JX3kq/src/parser.jl:127\n","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Now, we build the virtual mechanism, which consists of a virtual track that a virtual cart moves along. The virtual track is a Rail joint based upon the spline that we defined earlier. The virtual cart is connected to the robot's end effector by a virtual spring and damper, using the coordinate CartPosition. Coordinate CartDistance is the jointspace coordinate of the rail joint: distance the cart has moved along the virtual track. Components CartInertance and CartDamper are used to add inertance and damping to the cart, and can be thought of as the mass and friction of the cart, respectively. Notably, using a LinearInerter component here is equivalent to adding a mass to the cart which is not affected by the force of gravity.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"vm = Mechanism{Float64}(\"VirtualTrack\")\n\ncart_frame = add_frame!(vm, \"Cart\")\nadd_joint!(vm, Rail(spline, zero(Transform{Float64}));\n        parent=root_frame(vm), child=cart_frame,        id=\"RailJoint\")","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"\"RailJoint\"","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Jointspace components","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"add_coordinate!(vm, JointSubspace(\"RailJoint\");         id=\"CartDistance\")\nadd_coordinate!(vm, FrameOrigin(cart_frame);            id=\"CartPosition\")\nadd_component!(vm, LinearInerter(1.0, \"CartPosition\");  id=\"CartInertance\") # Cart mass\nadd_component!(vm, LinearDamper(100.0, \"CartPosition\"); id=\"CartDamper\");","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Now, we will combine the robot and the virtual mechanism into a single system. To do this we will create a VirtualMechanismSystem object, which will contain both the robot and the virtual mechanism. We will then add a CoordDifference component to the system, which will take the difference between the position of the virtual cart and the position of the robot's end effector. We will then add a spring and damper component to the system, which will constrain the robot to the path defined by the cart.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"Finally we will add a ForceSource component to the system, which will apply a driving force to the cart, to move it along the path. The force source will apply a force of 20N in the forward direction, unless doing so would exceed the maximum power of 10W, in which case the magnitude of the force will be reduced to ensure that the power does not exceed 10W.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"vms = VirtualMechanismSystem(\"System\", robot, vm)\nerr_coord = CoordDifference(\".virtual_mechanism.CartPosition\", \".robot.TCP\")\nerr_spring = LinearSpring(3000.0 * identity(3), \"CartError\")\nerr_damper = LinearDamper(50.0 * identity(3), \"CartError\")\n\nadd_coordinate!(vms, err_coord;     id=\"CartError\")\nadd_component!(vms, err_spring;     id=\"CartErrSpring\")\nadd_component!(vms, err_damper;     id=\"CartErrDamper\")\n\nmax_power = 10.0\nforce_source = ForceSource(SVector(20.0), max_power, \".virtual_mechanism.CartDistance\")\nadd_component!(vms, force_source;   id=\"Force source\");","category":"page"},{"location":"examples/compliant_path_following/#Setting-up-the-simulation","page":"Franka compliant path following","title":"Setting up the simulation","text":"","category":"section"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"We define a disturbance function that will apply a force of 20N in the negative x-direction between 3 and 6 seconds. We then define the f_control function, which will apply this disturbance force to the system. The f_control function is called once per timestep of the simulation, and can be used to apply external forces to the system. The f_setup function is used to get the coordinate ID of the TCP position at the beginning of the simulation, to be used in the f_control function.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"We then define the timespan, initial joint angles, joint velocities, and gravity vector for the simulation. We create a dynamics cache, and an ODE problem, and solve the ODE problem using the Tsit5 solver from DifferentialEquations.jl.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"f_setup(cache) = get_compiled_coordID(cache, \".robot.TCP\")\ndisturbance_func(t) = 3 < t < 6 ? SVector(-20., 0., 0.) : SVector(0., 0., 0.)\nfunction f_control(cache, t, args, extra)\n    tcp_pos_coord_id = args\n    F = disturbance_func(t)\n    uᵣ, uᵥ = get_u(cache)\n    z = configuration(cache, tcp_pos_coord_id)\n    J = jacobian(cache, tcp_pos_coord_id)\n    mul!(uᵣ, J', F)\n    nothing\nend\n\ncache = new_dynamics_cache(compile(vms))\ntspan = (0.0, 10.0)\nq = ([0.0, 0.1, 0.0, -2.5, pi/2, pi/2, 0.6], [0.0])\nq̇ = (zeros(7), zeros(1))\ngravity = VMRobotControl.DEFAULT_GRAVITY\nprob = get_ode_problem(cache, gravity, q, q̇, tspan; f_setup, f_control)\n@info \"Simulating compliant path following.\"\nsol = solve(prob, Tsit5(); maxiters=2e5, abstol=1e-6, reltol=1e-6);","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"[ Info: Simulating compliant path following.\n","category":"page"},{"location":"examples/compliant_path_following/#Visualizing-the-simulation","page":"Franka compliant path following","title":"Visualizing the simulation","text":"","category":"section"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"We will now visualize the simulation. We will create a Figure object, and add a LScene to it. We create an observable for the time, and an observable for the kinematics cache. These will be used by the animate_robot_odesolution function, which will update the observables, and therefore any plots that depend upon them, as it plays back the simulation solution.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"plotting_t = Observable(0.0)\nplotting_kcache = Observable(new_kinematics_cache(compile(vms)))\nplotting_vm_kcache = map(plotting_kcache) do k\n    VMRobotControl.virtual_mechanism_cache(k)\nend\ncartID = get_compiled_coordID(plotting_kcache[], \".virtual_mechanism.CartPosition\")\n\nfig = Figure(; size=(720, 720), figure_padding=0)\ndisplay(fig)\nls = LScene(fig[1, 1]; show_axis=false)\ncam = cam3d!(ls; center=false)\ncam.eyeposition[] = [0.912748151284803, 1.0895512157983234, 0.8513286633206905]\ncam.lookat[] = [0.09731484912188403, -0.18195162102725565, 0.17343471031108892];","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"The cart is visualized as a red rectangle. The rail is shown by sketching the virtual mechanism, and the robot is visualized using the robotvisualize! function.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"scatter!(ls, plotting_kcache, cartID; color=:red, marker=:rect, markersize=10)\nrobotvisualize!(ls, plotting_kcache)\nrobotsketch!(ls, plotting_vm_kcache);","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"To plot the force arrow, we first get the TCP position, and then calculate the force at the TCP position using the disturbance function. We then plot the force arrow at the TCP position. The size of the arrow is scaled according to the magnitude of the force.","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"tcp_pos_id = get_compiled_coordID(plotting_kcache[], \".robot.TCP\")\ntcp_pos = map(plotting_kcache) do kcache\n    Point3f(configuration(kcache, tcp_pos_id))\nend\nforce = map(t -> 0.01 * Vec3f(disturbance_func(t)), plotting_t)\narrowsize = map(f -> 0.1*(f'*f)^(0.25), force)\narrows!(ls, map(p -> [p], tcp_pos), map(f -> [f], force); color = :red, arrowsize)\n\nfps = 60\nT = sol.t[end]\nN_frames = Int(floor(fps * T))\nts = LinRange(0.0, T, N_frames)\nsavepath = joinpath(module_path, \"docs/src/assets/compliant_path_following.mp4\")\nanimate_robot_odesolution(fig, sol, plotting_kcache, savepath; t=plotting_t);","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"<video controls width=\"100%\" height=\"auto\" autoplay loop>\n<source src=\"../../assets/compliant_path_following.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"","category":"page"},{"location":"examples/compliant_path_following/","page":"Franka compliant path following","title":"Franka compliant path following","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"This tutorial will give an overview of the package so that you can be  proficient in building mechanisms, simulating, plotting and controlling robots.","category":"page"},{"location":"tutorials/introduction/#What-is-a-Mechanism?","page":"Introduction","title":"What is a Mechanism?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"You can think of a Mechanism as a robot.  There are three main parts to a mechanism. First is the rigid body tree, which should be familiar if you have worked with robot simulation before. This is composed of reference frames and joints (e.g. Revolute or Prismatic). This rigid body tree defines the set of minimal/generalized coordinates that  define the state of the robot–think q, dot q: the joint angles/ velocities.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"using VMRobotControl, StaticArrays\nmechanism = Mechanism{Float64}(\"MyRobot\")\nadd_frame!(mechanism; id=\"L1\")\naxis = SVector(0.0, 1.0, 0.0)\nadd_joint!(mechanism, Revolute(axis); parent=\"root_frame\", child=\"L1\", id=\"J1\")\nmechanism","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Second are the mechanism's coordinates. These are extra geometric points/ features of interest derived from the state of the rigid body tree. The simplest coordinate might be the FramePoint which represents a fixed point in a particular reference frame.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"tip_offset = SVector(0.0, 0.0, -1.0)\nadd_coordinate!(mechanism, FramePoint(\"L1\", tip_offset); id=\"tip_position\")\nmechanism","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Finally we have components, which include mass, inertia, springs, dampers and  inerters, among others. Here we add a pointmass to the tip of our pendulum.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"add_component!(mechanism, PointMass(1.0, \"tip_position\"); id=\"tip_mass\")\nmechanism","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Finally, we might wish to plot and simulate our mechanism. The details of how to do this are explained later, but here is an example.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"using GLMakie\nfig = Figure(size=(200, 200))\nls = LScene(fig[1, 1]; show_axis=false)\nm = compile(mechanism)\nkcache = Observable(new_kinematics_cache(m))\nroot_frame_id = get_compiled_frameID(m, \"root_frame\")\ncoord_id = get_compiled_coordID(m, \"tip_position\")\nrobotsketch!(ls, kcache; linewidth=2.0)\nscatterlines!(ls, kcache, [root_frame_id, coord_id]; color=:black, linewidth=2.0)\ntext!(ls, kcache, coord_id; text=\"tip_position\")\nsave(\"pendulum.png\", fig)\n\nusing DifferentialEquations\ndcache, gravity = new_dynamics_cache(m), VMRobotControl.DEFAULT_GRAVITY\nq, q̇, tspan = [1.0], [0.0], 10.0\nprob = get_ode_problem(dcache, gravity, q, q̇, tspan)\nsol = solve(prob)\nanimate_robot_odesolution(fig, sol, kcache, \"animation.mp4\")\nnothing","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"In the following sections you will learn how to ","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"build a mechanism\ncompile a mechanism for kinematics/dynamic computations\nmake a virtual mechanism system\nplot mechanisms/virtual mechanism systems with Makie.jl\nsimulate mechanisms/virtual mechanism systems with DifferentialEquation.jl\nperform realtime control\ndo AD/Optimization with ForwardDiff.jl or Enzyme.jl","category":"page"},{"location":"#VMRobotControl.jl","page":"Home","title":"VMRobotControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VMRobotControl allows you to build dynamic controllers for your robot as intuitive virtual mechanisms. You design your controller by building a virtual mechanism. You connect the virtual mechanism to the robot through compliant elements (like springs and dampers). The control action is automatically translated to the robot actuators (desired joint forces/torques).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is designed for building, simulating and controlling robots using passivity-based controllers represented by virtual mechanisms. This is in the tradition of virtual model control and energy shaping/damping injection. For a defined robot geometry, you can select specific coordinates and connect  components to shape the robot dynamic properties. properties. This provides a simple way to program complex robot behaviour incrementally, from mechanical  primitives.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video controls width=\"49%\" height=\"auto\" autoplay loop>\n    <source src=\"assets/franka_impedance_control.mp4\" type=\"video/mp4\">\n</video>\n<video controls width=\"49%\" height=\"auto\" autoplay loop>\n    <source src=\"assets/compliant_path_following.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Design-features","page":"Home","title":"Design features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy creation of rigid body mechanisms with dynamic components\nLibrary of components like springs and dampers, both linear and nonlinear\nLibrary of geometry 'coordinates' with Jacobians to help build components\nVirtualMechanismSystem type for building virtual-mechanism controllers\nAllocation free computation methods for fast simulation/control\nLoading URDFs\nPlotting and simulation with Makie.jl and DifferentialEquations.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video controls width=\"66%\" height=\"auto\" autoplay loop>\n    <source src=\"assets/rail_robot.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current recommended method to install this package is to clone the github repository and mark it as a package under development. In your terminal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:Cambridge-Control-Lab/VMRobotControl.jl.git\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then in julia, hit ] to enter Pkg mode, and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"registry update\ndev ./VMRobotControl.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video controls width=\"98%\" height=\"auto\" autoplay loop>\n    <source src=\"assets/sciurus_reaching.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Citing-this-library","page":"Home","title":"Citing this library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please cite this library as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{VMRobotControl,\n    author = {Daniel Larby},\n    title = {{VMRobotControl.jl}},\n    howpublished = {\\url{https://github.com/Cambridge-Control-Lab/VMRobotControl}},\n    year = {2024}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"and also consider citing the authors works on optimal virtual model control and robot control for robotic surgery.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Larby2024,\n      title={Optimal Virtual Model Control for Robotics: Design and Tuning of Passivity-Based Controllers}, \n      author={Daniel Larby and Fulvio Forni},\n      year={2024},\n      eprint={2411.06627},\n      archivePrefix={arXiv},\n      primaryClass={cs.RO},\n      doi = {https://doi.org/10.48550/arXiv.2411.06627},\n      url={https://arxiv.org/abs/2411.06627}, \n}\n@article{Larby2023,\n    title = {A Generalized Approach to Impedance Control Design for Robotic Minimally Invasive Surgery},\n    journal = {IFAC-PapersOnLine},\n    year = {2023},\n    note = {22nd IFAC World Congress},\n    doi = {https://doi.org/10.1016/j.ifacol.2023.10.015},\n    author = {Daniel Larby and Fulvio Forni},\n}","category":"page"},{"location":"#Authors-and-Acknowledgements","page":"Home","title":"Authors and Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I'm Daniel Larby. This package was initially developed during my PhD (here is my website!) at the Control Lab, in the Department of Engineering, University of Cambridge, CB2 1PZ, UK.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I was supported by my supervisor, Fulvio Forni, and the other students in the group.","category":"page"},{"location":"","page":"Home","title":"Home","text":"My PhD was graciously supported by the Engineering and Physical Sciences Research Council;  and by CMR Surgical.","category":"page"},{"location":"api/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Pages= [\"api/api.md]\"","category":"page"},{"location":"api/api/#Loading-from-RSON/URDF","page":"API","title":"Loading from RSON/URDF","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"parseRSON\nparseURDF\nRSONParserConfig\nURDFParserConfig\nserializeRSON","category":"page"},{"location":"api/api/#VMRobotControl.RSON.parseRSON","page":"API","title":"VMRobotControl.RSON.parseRSON","text":"parseRSON(filepath::AbstractString, [cfg::RSONParserConfig])\n\nParse a Mechanism or VirtualMechanismSystem from an RSON file (with a .rson extension).\n\nSee also parseRSONString, serializeRSON, RSONParserConfig.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.URDF.parseURDF","page":"API","title":"VMRobotControl.URDF.parseURDF","text":"parseURDF(filepath::AbstractString, [cfg::URDFParserConfig])\nparseURDF(cfg::URDFParserConfig)\n\nParse a Mechanism from a URDF file. If filepath is provided, a default config is used.  If ONLY cfg is provided, the URDF file path must be set in the config.\n\nSee also parseURDFString, [URDFParserConfig]\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.RSON.RSONParserConfig","page":"API","title":"VMRobotControl.RSON.RSONParserConfig","text":"mutable struct RSONParserConfig(; kwargs...)\n\nConfiguration for the RSON parser.\n\nFields\n\nOptions\n\nelement_type::Type: Type of the elements in the mechanism. Default is Float64.\nparse_visuals::Bool: Whether to parse visuals. Default is true.\nerror_on_not_supported::Bool: Whether to throw an error if an unsupported feature is encountered. Default is false.\nerror_on_not_recognized::Bool: Whether to throw an error if an unrecognized key is encountered. Default is true.\nsuppress_warnings::Bool: Whether to suppress warnings. Default is false.\ndefault_material::RGBA: Default material for visuals. Default is RGBA(0.8, 0.8, 0.8, 1.0).\n\nFields used by the parser\n\nrson_path::String: Path to the RSON file parsed. (Used to locate meshes)\nrson_version::Tuple{Int, Int, Int}: Version of the RSON file parsed.\nnamed_materials::Dict{String, RGBA}: Named materials for visuals. Default is an empty dictionary.\n\nInternal\n\nname_stack::Vector{String}: Stack of names for error messages.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.URDF.URDFParserConfig","page":"API","title":"VMRobotControl.URDF.URDFParserConfig","text":"mutable struct URDFParserConfig\n\nUsed to configure the URDF parser. WARNING: may be modified during parsing (e.g. materials are added to named materials).\n\nFields\n\nurdf_path::String: Path to the URDF file.\nelement_type::Type: eltype to build the mechanism with, default Float64.\nparse_visuals::Bool: Whether to parse visual elements, default true.\nerror_on_not_supported::Bool: Whether to error on unsupported URDF features, default false.\nerror_on_not_recognized::Bool: Whether to error on unrecognized URDF features, default true.\nsuppress_warnings::Bool: Whether to suppress warnings, default false.\ndefault_material::RGBA: Default colour to use for visuals, default RGBA(0.8, 0.8, 0.8, 1.0).\nnamed_materials::Dict{String, RGBA}: Named materials to use for visuals, default Dict().\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.RSON.serializeRSON","page":"API","title":"VMRobotControl.RSON.serializeRSON","text":"serializeRSON(filepath, m::Union{Mechanism, VirtualMechanismSystem})\n\nTakes a mechanism or virtual mechanism system and serializes it to a file at filepath in the RSON  format. \n\nWhen handling visuals, the mesh data is serialized as a list of vertices and faces. \n\nDoes not guarantee that a parsed RSON is serialized back into an identical RSON, but the mechanism should be the same.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Building","page":"API","title":"Building","text":"","category":"section"},{"location":"api/api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Mechanism\nVirtualMechanismSystem","category":"page"},{"location":"api/api/#VMRobotControl.Mechanism","page":"API","title":"VMRobotControl.Mechanism","text":"Mechanism{T}(name; with_root_frame=true)\n\nA rigid body 'Mechanism', composed of reference frames, joints, coordinates and  dynamic components.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.VirtualMechanismSystem","page":"API","title":"VMRobotControl.VirtualMechanismSystem","text":"VirtualMechanismSystem{T}(name)\nVirtualMechanismSystem(name, robot::Mechanism{T}, [virtual_mechanism::Mechanism{T}])\n\nConstruct a virtual mechanism system. If only a name is provided, then an empty virtual mechanism  system is created, and the robot/virtual mechanism can be accessed by the robot and virtual_mechanism fields.\n\nCoordinates and components can then be added to the virtual mechanism system, and these can act  inbetween the robot and the virtual mechanism. Coordinates on the robot/virtual mechanism can be  referenced using the naming syntax \".robot.coordID\" or \".virtual_mechanism.coordID\".\n\nNote: the robot and virtual mechanism are not copied, so modifying them after creating the virtual  mechanism system WILL modify the virtual mechanism system.\n\nSee also Mechanism, add_coordinate!, add_component!\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Accessing-Mechanisms/Virtual-Mechanism-Systems","page":"API","title":"Accessing Mechanisms/Virtual Mechanism Systems","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"name\nframes\nnum_frames\nroot_frame\njoints\ncoordinates\ncomponents\nconfig_size\nvelocity_size\nndof\ninertances\nstorages\ndissipations\ngeneric_components\nvisuals","category":"page"},{"location":"api/api/#VMRobotControl.name","page":"API","title":"VMRobotControl.name","text":"name(m::Union{Mechanism, CompiledMechanism, VirtualMechanismSystem, CompiledVirtualMechanismSystem})\n\nReturns the name of the mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.frames","page":"API","title":"VMRobotControl.frames","text":"frames(m::Union{Mechanism, CompiledMechanism})\n\nReturns a vector of the names of the frames in the mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.num_frames","page":"API","title":"VMRobotControl.num_frames","text":"num_frames(m::Union{Mechanism, CompiledMechanism})\n\nReturns the number of reference frames in the mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.root_frame","page":"API","title":"VMRobotControl.root_frame","text":"root_frame(m::Union{Mechanism, CompiledMechanism})\n\nReturns the name of the first frame of the mechanism. This should be the root frame of the tree and should be called \"root_frame\".\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.joints","page":"API","title":"VMRobotControl.joints","text":"joints(m::Union{Mechanism, CompiledMechanism})\n\nReturns joints in the mechanism. \n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is an OrderedDict. Mutating it WILL mutate the mechanism. If m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem}  this is a TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_joint! to add joints to the mechanism, and get_compiled_jointID to get an ID/index for modifying joints in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.coordinates","page":"API","title":"VMRobotControl.coordinates","text":"coordinates(m::Union{Mechanism, CompiledMechanism, VirtualMechanismSystem, CompiledVirtualMechanismSystem})\n\nReturns the coordinates of the system. \n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict. Mutating the returned Dict WILL mutate the mechanism. If m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem}  this is a TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_coordinate! to add coordinates to the mechanism, and  get_compiled_coordID to get an ID/index for modifying coordinates in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.components","page":"API","title":"VMRobotControl.components","text":"components(m::Union{Mechanism, CompiledMechanism, VirtualMechanismSystem, CompiledVirtualMechanismSystem})\n\nReturns the dynamic components of the mechanism (e.g. springs/dampers/masses). \n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict. Mutating the returned Dict WILL mutate the mechanism. If m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem}  this is a TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_component! to add components to the mechanism, and get_compiled_componentID to get an ID/index for modifying components in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.config_size","page":"API","title":"VMRobotControl.config_size","text":"config_size(m::Union{Mechanism, CompiledMechanism})\n\nReturns the number of configuration variables in the mechanism (e.g. the number of joint angles), the length of the joint configuration vector q.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.velocity_size","page":"API","title":"VMRobotControl.velocity_size","text":"velocity_size(m::Union{Mechanism, CompiledMechanism})\n\nReturns the number of velocity variables in the mechanism (e.g. the number of joint velocities), the length of the joint velocity vector q̇.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.ndof","page":"API","title":"VMRobotControl.ndof","text":"ndof(m::Union{Mechanism, CompiledMechanism, VirtualMechanismSystem, CompiledVirtualMechanismSystem})\n\nThe number of degrees of freedom of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.inertances","page":"API","title":"VMRobotControl.inertances","text":"inertances(m::Union{Mechanism, CompiledMechanism, VirtualMechanismSystem, CompiledVirtualMechanismSystem})\n\nReturns the inertance components of the system.\n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict formed by filtering the components by Inertance type:  mutating the returned Dict WILL NOT mutate the mechanism.\n\nIf m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem}  this is a TypeStableCollection made from a subset of the vectors in the components TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_component! to add components to the mechanism, and get_compiled_componentID to get an ID/index for modifying components in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.storages","page":"API","title":"VMRobotControl.storages","text":"storages(m::AbstractMechanism)\n\nReturns the storage components from mechanism.\n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict formed by filtering the components by Storage type: mutating the returned Dict WILL NOT mutate the mechanism.\n\nIf m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem} this is a TypeStableCollection made from a subset of the vectors in the components TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_component! to add components to the mechanism, and get_compiled_componentID to get an ID/index for modifying components in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.dissipations","page":"API","title":"VMRobotControl.dissipations","text":"dissipations(m::AbstractMechanism)\n\nReturns the dissipation components from mechanism.\n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict formed by filtering the components by Dissipation type: mutating the returned Dict WILL NOT mutate the mechanism.\n\nIf m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem} this is a TypeStableCollection made from a subset of the vectors in the components TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_component! to add components to the mechanism, and get_compiled_componentID to get an ID/index for modifying components in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.generic_components","page":"API","title":"VMRobotControl.generic_components","text":"generic_components(m::AbstractMechanism)\n\nReturns the generic components from mechanism.\n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict formed by filtering the components by GenericComponent type: mutating the returned Dict WILL NOT mutate the mechanism.\n\nIf m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem} this is a TypeStableCollection made from a subset of the vectors in the components TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.visuals","page":"API","title":"VMRobotControl.visuals","text":"visuals(m::AbstractMechanism)\n\nReturns the visual components from mechanism.\n\nIf m<:Union{Mechanism, VirtualMechanismSystem} this is a Dict formed by filtering the components by Visual type: mutating the returned Dict WILL NOT mutate the mechanism.\n\nIf m<:Union{CompiledMechanism, CompiledVirtualMechanismSystem} this is a TypeStableCollection made from a subset of the vectors in the components TypeStableCollection. Mutating the returned collection WILL mutate the mechanism.\n\nIt is recommended to use add_component! to add components to the mechanism, and get_compiled_componentID to get an ID/index for modifying components in compiled systems.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Building-methods","page":"API","title":"Building methods","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"add_frame!\nadd_joint!\nadd_coordinate!\nadd_component!\nadd_inertia!\nadd_gravity_compensation!\nadd_gravity_compensator!","category":"page"},{"location":"api/api/#VMRobotControl.add_frame!","page":"API","title":"VMRobotControl.add_frame!","text":"add_frame!(m::Mechanism; id::String)\n\nAdd a frame to a mechanism. The name must be unique.\n\nSee also frames, add_joint!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_joint!","page":"API","title":"VMRobotControl.add_joint!","text":"add_joint!(mechanism, jointdata; [parent, child, jointID, check_frames_exist::Bool])\n\nAdd a joint to a mechanism. Returns the joint id.\n\nArguments\n\njointID: the name of the joint, a String. If not provided, a unique jointID is created.\nparent: the name of the parent frame, a String. If not provided, then the default is the most recently added frame.\nchild the name of the child frame, a String. If not provided, adds a new frame to the robot. \ncheck_frames_exist: if true, then check that the parent and child frame already exist in the   mechanism. If false, then this check is skipped. In this case the frames are not added to the   mechanism.\n\nSee Also\n\nTo add a frame to a mechanism see add_frame!. For more information on types of joint see AbstractJointData and MechanismJoint.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_coordinate!","page":"API","title":"VMRobotControl.add_coordinate!","text":"add_coordinate!(m::Mechanism, c::CoordinateData; id::String)\nadd_coordinate!(m::VirtualMechanismSystem, c::CoordinateData; id::String)\n\nAdd a coordinate to a mechanism or virtual mechanism system. The coordID is the name of the  coordinate. \n\nSee also get_compiled_coordID, configuration, velocity,  acceleration, jacobian\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_component!","page":"API","title":"VMRobotControl.add_component!","text":"add_component!(m::Mechanism, c::ComponentData; id::String)\nadd_component!(m::VirtualMechanismSystem, c::ComponentData; id::String)\n\nAdd a coordinate to a mechanism or virtual mechanism system. The coordID is the name of the  coordinate. \n\nSee also get_compiled_componentID\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_inertia!","page":"API","title":"VMRobotControl.add_inertia!","text":"add_inertia!(mechanism, frameID, inertia; id, coordID=nothing)\n\nAdd an inertia to a mechanism. A FrameAngularVelocity coordinate is added to the mechanism, on the frame with ID frameID, and is given the ID coordID if  provided. \n\nThe inertia is defined by a 3x3 matrix inertia.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_gravity_compensation!","page":"API","title":"VMRobotControl.add_gravity_compensation!","text":"add_gravity_compensation!(system, gravity)\n\nAdd gravity compensators for all point masses.\n\nIf system is a VirtualMechanismSystem, then only point masses in the robot are compensated, and the GravityCompensator components are added to the system, so that they are treated as  part of the controller, not part of the robot.  \n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.add_gravity_compensator!","page":"API","title":"VMRobotControl.add_gravity_compensator!","text":"add_gravity_compensator!(mechanism, point_mass, gravity; id=nothing)\n\nAdd a gravity compensator to componsate for point_mass, when subject to gravity.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Using","page":"API","title":"Using","text":"","category":"section"},{"location":"api/api/#Compiling-and-Cache-bundles","page":"API","title":"Compiling and Cache-bundles","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"compile\nnew_kinematics_cache\nnew_jacobians_cache\nnew_rbstates_cache\nnew_dynamics_cache\nnew_control_cache","category":"page"},{"location":"api/api/#VMRobotControl.compile","page":"API","title":"VMRobotControl.compile","text":"compile(m::Mechanism)\ncompile(m::VirtualMechanismSystem)\n\nCompile a Mechanism or VirtualMechanismSystem into an immutable form used for computations.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.new_kinematics_cache","page":"API","title":"VMRobotControl.new_kinematics_cache","text":"new_kinematics_cache(m[, T])\n\nCreates a cache with element type ::T (defaulting to the eltype of the mechanism) for performing  kinematics computations for a compiled mechanism or compiled virtual mechanism system. \n\nThis cache supports computation of frame transforms and coordinate configuration's, but do NOT support computing jacobians or velocities.\n\nThis type of cache is commonly used for plotting, where only the frame transforms are needed.\n\nSee also kinematics!, new_jacobians_cache, new_rbstates_cache,  new_dynamics_cache, \n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.new_jacobians_cache","page":"API","title":"VMRobotControl.new_jacobians_cache","text":"new_jacobians_cache(m[, T])\n\nCreates a cache with element type ::T (defaulting to the eltype of the mechanism) for performing kinematics and jacobian computations for a compiled mechanism or compiled virtual mechanism system.\n\nThis cache supports computation of frame transforms and jacobians, configuration and  jacobian for coordinates, but do NOT support velocities.\n\nSee also jacobians!, new_rbstates_cache, new_dynamics_cache, \n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.new_rbstates_cache","page":"API","title":"VMRobotControl.new_rbstates_cache","text":"new_rbstates_cache(m[, T])\n\nCreates a cache with element type ::T (defaulting to the eltype of the mechanism) for performing kinematics and velocity computations for a compiled mechanism or compiled virtual mechanism system.\n\nThis cache supports computation of frame transforms, velocities and accelerations. Depending on which computation is performed, velocity_kinematics! or  acceleration_kinematics!, the acceleration will either be a true acceleration dependant upon joint accelerations q̈, or the velocity product acceleration, which is the acceleration assuming q̈ = 0. It supports configuration, velocity, and acceleration, for coordinates. It does NOT support jacobians or generalized forces/torques.\n\nSee also velocity_kinematics! new_dynamics_cache, \n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.new_dynamics_cache","page":"API","title":"VMRobotControl.new_dynamics_cache","text":"new_dynamics_cache(m[, T])\n\nCreates a cache with element type ::T (defaulting to the eltype of the mechanism) for performing kinematics, jacobian, and velocity computations for a compiled mechanism or compiled virtual mechanism system, as well as generalized forces/torques from components, the inertance matrix, of the system, and the acceleration of the system, q̈.\n\nThis cache supports computation of frame transforms, velocities, velocity-product-accelerations, and jacobians. It also supports configuration, velocity, acceleration, and jacobian for coordinates.\n\nSee also dynamics!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.new_control_cache","page":"API","title":"VMRobotControl.new_control_cache","text":"new_control_cache(m[, T])\n\nCreates a cache with element type ::T (defaulting to the eltype of the mechanism) for controlling a robot with a virtual mechanism controller.\n\nnote: Note\nComponents attached to the robot will NOT be used for control.  The components on the robot represent the model of the robot, and are not considered part of  the controller. If you wish to control the robot, you must add components to the VirtualMechanismSystem. If your component uses a coordinate from the robot, you can add it to the VirtualMechanismSystem and refer to the coordinate using the id \".robot.<coord_id>\"\n\nSee also control_step!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Accessing-data-from-cache-bundles","page":"API","title":"Accessing data from cache-bundles","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_rbstate\nget_transform\nget_linear_vel\nget_angular_vel\nget_linear_vpa\nget_angular_vpa\nget_linear_acceleration\nget_angular_acceleration\nget_linear_jacobian\nget_angular_jacobian\nget_t\nget_q\nget_q̇\nget_q̈\nget_u\nget_inertance_matrix\nget_generalized_force","category":"page"},{"location":"api/api/#VMRobotControl.get_rbstate","page":"API","title":"VMRobotControl.get_rbstate","text":"get_rbstate(cache, frame::CompiledFrameID)\n\nReturns the rigid body state of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_transform","page":"API","title":"VMRobotControl.get_transform","text":"get_transform(cache, frame::CompiledFrameID)\n\nReturns the transform of the frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_linear_vel","page":"API","title":"VMRobotControl.get_linear_vel","text":"get_linear_vel(cache, frame::CompiledFrameID)\n\nReturns the linear velocity of the origin of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_angular_vel","page":"API","title":"VMRobotControl.get_angular_vel","text":"get_angular_vel(cache, frame::CompiledFrameID)\n\nReturns the angular velocity of the frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_linear_vpa","page":"API","title":"VMRobotControl.get_linear_vpa","text":"get_linear_vpa(cache, frame::CompiledFrameID)\n\nReturns the linear velocity product acceleration of the origin of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_angular_vpa","page":"API","title":"VMRobotControl.get_angular_vpa","text":"get_angular_vpa(cache, frame::CompiledFrameID)\n\nReturns the angular velocity product acceleration of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_linear_acceleration","page":"API","title":"VMRobotControl.get_linear_acceleration","text":"get_linear_acceleration(cache, frame::CompiledFrameID)\n\nReturns the total linear acceleration of the origin of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_angular_acceleration","page":"API","title":"VMRobotControl.get_angular_acceleration","text":"get_angular_acceleration(cache, frame::CompiledFrameID)\n\nReturns the total angular acceleration of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_linear_jacobian","page":"API","title":"VMRobotControl.get_linear_jacobian","text":"get_linear_jacobian(cache, frame::CompiledFrameID)\n\nReturns the linear Jacobian of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_angular_jacobian","page":"API","title":"VMRobotControl.get_angular_jacobian","text":"get_angular_jacobian(cache, frame::CompiledFrameID)\n\nReturns the angular Jacobian of frame from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_t","page":"API","title":"VMRobotControl.get_t","text":"get_t(cache)\n\nReturns the time from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_q","page":"API","title":"VMRobotControl.get_q","text":"get_q(cache)\n\nReturns the joint configurations from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_q̇","page":"API","title":"VMRobotControl.get_q̇","text":"get_q̇(cache)\n\nReturns the joint velocities from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_q̈","page":"API","title":"VMRobotControl.get_q̈","text":"get_q̈(cache)\n\nReturns the joint accelerations from the cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_u","page":"API","title":"VMRobotControl.get_u","text":"get_u(cache)\n\nReturns the additional joint torques from the cache. \n\nThis can be used during f_control to apply additional torques to the system, by modifying the  returned torques inplace. By default, these torques are zero until set otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_inertance_matrix","page":"API","title":"VMRobotControl.get_inertance_matrix","text":"get_inertance_matrix(cache)\n\nReturns the inertance matrix in the cache.\n\nFor a virtual mechanism system, this is a tuple of inertance matrices: one for the robot and one  for the virtual mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_generalized_force","page":"API","title":"VMRobotControl.get_generalized_force","text":"get_generalized_force(cache)\n\nReturns the generalized forces in the cache.\n\nFor a virtual mechanism system, this is a tuple of vectors: one for the robot and one for the  virtual mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Computations","page":"API","title":"Computations","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"kinematics!\njacobians!\nvelocity_kinematics!\nacceleration_kinematics!\nprecompute!\ngeneralized_force!\ninertance_matrix!\ndynamics!\ncontrol_step!\nstored_energy\nopspace_force","category":"page"},{"location":"api/api/#VMRobotControl.kinematics!","page":"API","title":"VMRobotControl.kinematics!","text":"kinematics!(bundle, t, q)\n\nCompute the kinematics/transforms for the system.\n\nArguments\n\nt time\nq joint configuration vector\n\nSee also get_transform\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.jacobians!","page":"API","title":"VMRobotControl.jacobians!","text":"jacobians!(bundle, t, q)\n\nCompute the Jacobians for the mechanism at time t and configuration q and store them in cache.jacobians.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.velocity_kinematics!","page":"API","title":"VMRobotControl.velocity_kinematics!","text":"velocity_kinematics!(cache, t, q, q̇)\n\nCompute the velocities of the system at time t and configuration q, with velocities q̇, and store them in cache.rbstates. Also computes the velocity product accelerations (i.e. accelerations assuming q̈ = 0).\n\nAlso computes the kinematics as a prerequisite.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.acceleration_kinematics!","page":"API","title":"VMRobotControl.acceleration_kinematics!","text":"acceleration_kinematics!(bundle, t, q, q̇, q̈)\n\nCompute the accelerations for the mechanism with known joint-accelerations q̈.\n\nAlso computes the kinematics/velocities as prerequisites.\n\nArguments\n\nt time\nq joint configuration vector\nq̇ joint velocity vector\nq̈ joint acceleration vector\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.precompute!","page":"API","title":"VMRobotControl.precompute!","text":"precompute!(cache, t, q, q̇, gravity, u)\n\nPrecompute the necessary quantities for the dynamics of the mechanism at time t and configuration  q, with velocities q̇, gravitational acceleration gravity, and generalized forces u.\n\nThis includes the velocity kinematics and Jacobians, and stores the results in cache.  The accelerations q̈ are not computed.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.generalized_force!","page":"API","title":"VMRobotControl.generalized_force!","text":"generalized_force!(τ, bundle::CacheBundle, c::ComponentData)\n\nUsing the current state of the the cache, calculates the generalized force due to component c, and adds it to τ. \n\nTypically τ is a vector from the cache, but it is kept as an argument to allow for more flexibility in the use of this function.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.inertance_matrix!","page":"API","title":"VMRobotControl.inertance_matrix!","text":"inertance_matrix!(M, bundle::CacheBundle, c::ComponentData)\n\nUsing the current state of the cache, calculates the inertance matrix due to component c, and adds it to M. \n\nTypically M is a matrix from the cache, but it is kept as an argument to allow for more flexibility in the use of this function.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.dynamics!","page":"API","title":"VMRobotControl.dynamics!","text":"dynamics!(cache, t, q, q̇, gravity, [u])\n\nCompute the accelerations for the mechanism at time t and configuration q, with velocities q̇, gravitational acceleration gravity, and generalized forces u, and store the results in the  cache.\n\nIf u is not provided, it is assumed to be zero.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.control_step!","page":"API","title":"VMRobotControl.control_step!","text":"control_step!(bundle, t, qʳ, q̇ʳ)\n\nPerform a step of the control loop for the system.\n\nInputs are the current time t, the robot joint configuration qʳ, and the robot joint velocity  q̇ʳ.\n\nThe elapsed time dt is computed from the previous time  and t. The virtual mechanism state is updated using a forward Euler step with the computed acceleration q̈ᵛ and the elapsed time dt.\n\nnote: Note\nComponents attached to the robot will NOT be used for control.  The components on the robot represent the model of the robot, and are not considered part of  the controller. If you wish to control the robot, you must add components to the VirtualMechanismSystem. If your component uses a coordinate from the robot, you can add it to the VirtualMechanismSystem and refer to the coordinate using the id \".robot.<coord_id>\"\n\nReturns the torques to be applied to the robot.\n\nSee also control_step!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.stored_energy","page":"API","title":"VMRobotControl.stored_energy","text":"stored_energy(bundle::MechanismCacheBundle, c::ComponentData)\n\nComputes the stored energy of component c, kinetic and potential.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.opspace_force","page":"API","title":"VMRobotControl.opspace_force","text":"opspace_force(bundle::MechanismCacheBundle, c::ComponentData)\n\nCalulates and returns the operational space force due to component c.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Accessing-compiled-frames/coords/joints/components","page":"API","title":"Accessing compiled frames/coords/joints/components","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_compiled_frameID\nget_compiled_coordID\nget_compiled_jointID\nget_compiled_componentID","category":"page"},{"location":"api/api/#VMRobotControl.get_compiled_frameID","page":"API","title":"VMRobotControl.get_compiled_frameID","text":"get_compiled_frameID(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem}, c::String)\n\nReturns compiled frame ID of frame with name c. This can be used to get the frames's transform, velocity, jacobian etc. from a kinematics/dynamics cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_compiled_coordID","page":"API","title":"VMRobotControl.get_compiled_coordID","text":"get_compiled_coordID(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem}, c::String)\n\nReturns the compiled coordinate ID of a coordinate with name c. This can be used to get the  configuration/velocity/jacobian of a coordinate from a kinematics/dynamics cache.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_compiled_jointID","page":"API","title":"VMRobotControl.get_compiled_jointID","text":"get_compiled_jointID(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem}, c::String)\n\nReturns the compiled joint ID of a joint with name c. This can be used to change the joint data for a compiled system, e.g. when numerically optimizing the robot structure.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_compiled_componentID","page":"API","title":"VMRobotControl.get_compiled_componentID","text":"get_compiled_componentID(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem}, c::String)\n\nReturns the compiled component ID of a component with name c. Can be used to mutate the component data of a compiled mechanism, or recompute information such as the force generated by the component.  \n\n\n\n\n\n","category":"function"},{"location":"api/api/#Setting-up-simulations","page":"API","title":"Setting up simulations","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"get_ode_dynamics\nassemble_state\nget_ode_problem\nzero_q\nzero_q̇\nzero_q̈\nzero_u","category":"page"},{"location":"api/api/#VMRobotControl.get_ode_dynamics","page":"API","title":"VMRobotControl.get_ode_dynamics","text":"get_ode_dynamics(cache, gravity; [f_setup, f_control])\n\nReturns a function for the autonomous ODE dynamics of the mechanism in the form     ̇x = f(x, p, t) where the parameters p are ignored.\n\nThis form is used for DifferentialEquations.jl\n\nf_setup, f_control, and f_shutdown\n\nThe optional keyword arguments f_setup and f_control are functions that can be used  to implement custom behaviour.\n\nf_setup(cache) is called once before starting.\nf_control(cache, t, setup_ret, extra) is called at each time step to allow for custom control  logic. setup_ret is the return value of f_setup, and can be used to initialize variables  before the controller starts. You can directly modify the robot/virtual mechanism state in this function, or modify the vectors returned by get_u(cache) to apply additional actuation to the robot or virtual mechanism.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.assemble_state","page":"API","title":"VMRobotControl.assemble_state","text":"assemble_state(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem}, q, q̇)\n\nAssembles a state vector from a configuration q and velocity q̇. This is useful for setting up ODEs for simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.get_ode_problem","page":"API","title":"VMRobotControl.get_ode_problem","text":"get_ode_problem(cache, gravity, q, q̇, tspan, [p, f_setup, f_control]; kwargs...)\n\nConstruct an ODE problem. See also VMRobotControl.get_ode_dynamics. initial conditions are given by q and q̇.\n\nDifferentialEquations.jl must be loaded for this method to be defined: using DifferentialEquations Implementations are in in ./ext/VMRobotControlDifferentialEquationsExt.jl\n\np and kwargs are optional arguments that can be used to customize the ODEProblem. f_setup and f_control are optional arguments that can be used to customize the dynamics function.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.zero_q","page":"API","title":"VMRobotControl.zero_q","text":"zero_q(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem})\n\nReturns a zero configuration for the system. For a mechanism, this is a vector of zeros, and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot, one for the virtual mechanism).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.zero_q̇","page":"API","title":"VMRobotControl.zero_q̇","text":"zero_q̇(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem})\n\nReturns a zero velocity for the system. For a mechanism, this is a vector of zeros, and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot, one for the virtual mechanism).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.zero_q̈","page":"API","title":"VMRobotControl.zero_q̈","text":"zero_q̈(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem})\n\nReturns a zero acceleration for the system. For a mechanism, this is a vector of zeros, and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot, one for the virtual mechanism).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.zero_u","page":"API","title":"VMRobotControl.zero_u","text":"zero_u(m::Union{CompiledMechanism, CompiledVirtualMechanismSystem})\n\nReturns a zero control input for the system. For a mechanism, this is a vector of zeros, and for a virtual mechanism system, this is a tuple of vectors of zeros (one for the robot, one for the virtual mechanism).\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/api/#Joints","page":"API","title":"Joints","text":"","category":"section"},{"location":"api/api/#AbstractJointData-types","page":"API","title":"AbstractJointData types","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Rigid\nRevolute\nPrismatic\nRail\nReferenceJoint","category":"page"},{"location":"api/api/#VMRobotControl.Rigid","page":"API","title":"VMRobotControl.Rigid","text":"Rigid(::Transform)\n\nA rigid joint, defined simply by a transformation from the child frame to the  parent frame.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.Revolute","page":"API","title":"VMRobotControl.Revolute","text":"Revolute(axis::SVector{3})\nRevolute(axis::SVector{3}, tf::Transform)\n\nRepresents a revolute/rotating joint between two frames. The transform from the child frame to the parent frame is tf * Transform(AxisAngle(axis, q)).\n\naxis must be normalized: norm(axis)≈1.0.\n\nSee also Prismatic, Rail\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.Prismatic","page":"API","title":"VMRobotControl.Prismatic","text":"Prismatic(axis::SVector{3})\nPrismatic(axis::SVector{3}, tf::Transform)\n\nRepresents a prismatic/sliding joint between two frames. The transform from the child frame to the parent frame is tf * Transform(q*axis). The axis does not have to be normalized.\n\nSee also Revolute, Rail, \n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.Rail","page":"API","title":"VMRobotControl.Rail","text":"Rail(spline, tf::Transform)\nRail(spline)\n\nRepresents a prismatic/sliding joint where the joint slides along a bezier  spline. The child frame is not rotated relative to the parent frame, (unless tf causes a rotation). \n\nThe origin of the parent frame for joint variable q is  tf * spline_position(spline, q).\n\nSee also Prismatic, Revolute\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.ReferenceJoint","page":"API","title":"VMRobotControl.ReferenceJoint","text":"ReferenceJoint(::Transform)\n\nA ReferenceJoint does not exhibit dynamics, but can it's transform can be mutated, so that it may act as a motion source. The transform is stored as A RefValue, which you can set/getcan like: joint.transform[].\n\nBe careful when changing the transform–-if you are doing many simulations you may need to deepcopy to avoid aliasing.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Coordinates","page":"API","title":"Coordinates","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"VMRobotControl.CoordinateData","category":"page"},{"location":"api/api/#VMRobotControl.CoordinateData","page":"API","title":"VMRobotControl.CoordinateData","text":"CoordinateData\n\nAn abstract type representing an operation space coordinate.\n\nSee also: configuration, velocity, jacobian and acceleration\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Coordinate-Interface","page":"API","title":"Coordinate Interface","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"configuration\nvelocity\njacobian\nacceleration","category":"page"},{"location":"api/api/#VMRobotControl.configuration","page":"API","title":"VMRobotControl.configuration","text":"configuration(cache, coordinate)\n\nReturns the configuration of the operation space coordinate coordinate z.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.velocity","page":"API","title":"VMRobotControl.velocity","text":"velocity(cache, coordinate)\n\nReturns the velocity of the operation space coordinate coordinate ż, the  derivative of the configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.jacobian","page":"API","title":"VMRobotControl.jacobian","text":"jacobian(cache, coordinate)\n\nReturn the jacobian of the operation space coordinate coordinate J, such that ż = Jq̇, where ż is the opspaceVelocity and q̇ are the joint velocities.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#VMRobotControl.acceleration","page":"API","title":"VMRobotControl.acceleration","text":"acceleration(cache, coordinate)\n\nReturns the acceleration of the operation space coordinate coordinate z̈, the second derivative of the configuration. Depending on the type of cache, this may either be velocity product acceleration or total acceleration.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Coordinate-types","page":"API","title":"Coordinate types","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"CoordDifference\nCoordNorm\nCoordStack\nCoordSlice\nCoordSum\nConstCoord\nJointSubspace\nFrameOrigin\nFramePoint\nFrameAngularVelocity\nQuaternionAttitude\nReferenceCoord\nRotatedCoord\nUnrotatedCoord","category":"page"},{"location":"api/api/#VMRobotControl.CoordDifference","page":"API","title":"VMRobotControl.CoordDifference","text":"CoordDifference(parent, child)\nCoordDifference(;parent, child)\n\nRepresents the difference between two coordinates. For example if both coordinates are cartesian  postions, then this represents the vector from one to the other.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.CoordNorm","page":"API","title":"VMRobotControl.CoordNorm","text":"CoordNorm(coord)\n\nTakes the norm of a coordinate zⁱ: i.e.     z = ∥zⁱ∥ \n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.CoordStack","page":"API","title":"VMRobotControl.CoordStack","text":"CoordStack(c1, c2)\nCoordStack(;c1, c2)\n\nRepresents the vertical concatenation of two coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.CoordSlice","page":"API","title":"VMRobotControl.CoordSlice","text":"CoordSlice(coordid, idxs::SVector{N, Int})\n\nA coordinate made by indexing into another coordinate.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.CoordSum","page":"API","title":"VMRobotControl.CoordSum","text":"CoordSum(c1, c2)\nCoordSum(;c1, 1child)\n\nRepresents the sum of two coordinates. \n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.ConstCoord","page":"API","title":"VMRobotControl.ConstCoord","text":"ConstCoord(::SVector)\n\nA constant coordinate. Can be used with coordinate differences to shift the equilibrium of a spring.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.JointSubspace","page":"API","title":"VMRobotControl.JointSubspace","text":"JointSubspace(jointid)\n\nRepresents the configuration of the joint identified by jointid. \n\nWhen compiled, is replaced with the compiled mechanism joint representation. This is because the joint type is needed to know the size of the joint.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.FrameOrigin","page":"API","title":"VMRobotControl.FrameOrigin","text":"FrameOrigin(frameID)\n\nThe position of the origin of frame frameID in the world.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.FramePoint","page":"API","title":"VMRobotControl.FramePoint","text":"FramePoint(frameID, point::SVector{3})\n\nA point fixed in the frame designated by frameID. point is the position of the point in the frame. The configuration of this coordinate is the vector to the point,  represented in the root frame of the mechanism.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.FrameAngularVelocity","page":"API","title":"VMRobotControl.FrameAngularVelocity","text":"FrameAngularVelocity(frameID)\n\nThe angular velocity for frame frameID in world frame. Used to implement rotational inertia components..\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.QuaternionAttitude","page":"API","title":"VMRobotControl.QuaternionAttitude","text":"QuaternionAttitude(frameID)\n\nThe rotation for frame frameID in the world, as the vector part of the  the quaternion. Can be combined with a linear spring for continuous attitude control.\n\nSee \"Quaternion-based impedance with nondiagonal stiffness for robot  manipulators\" by Fabrizio Caccavale et al, 1998 IEEE ACC.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.ReferenceCoord","page":"API","title":"VMRobotControl.ReferenceCoord","text":"ReferenceCoord(::Base.RefValue{SVector{N, T}})\n\nA reference coordinate. By keeping a reference to a coordinate, it can be  modified in place.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.RotatedCoord","page":"API","title":"VMRobotControl.RotatedCoord","text":"RotatedCoord(worldframecoord, frameID)\n\nRotates worldframecoordinate z⁽ʷ⁾ to the frame of link designated by frameID, such that z = R⁻¹ z⁽ʷ⁾.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.UnrotatedCoord","page":"API","title":"VMRobotControl.UnrotatedCoord","text":"UnrotatedCoord(linkframecoord, frameID)\n\nRotates link frame coordinate z⁽ˡ⁾ from the frame of link designated by frameID, to the world frame, so that  z = Rʷˡ z⁽ˡ⁾.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#Components","page":"API","title":"Components","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"VMRobotControl.Storage\nLinearSpring\nTanhSpring\nGaussianSpring\nGravityCompensator\nForceSource\nPowerSource\nLinearDamper\nTanhDamper\nRectifiedDamper\nDiodicDamper\nLinearInerter\nInertia\nPointMass","category":"page"},{"location":"api/api/#VMRobotControl.Storage","page":"API","title":"VMRobotControl.Storage","text":"Storage{T} <: ComponentData{T}\n\nSupertype for components that act as potential energy storages, with float type T.\n\nThese must support implement stored_energy and generalized_force!, typically by  implementing _stored_energy and _opspace_force functions, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.LinearSpring","page":"API","title":"VMRobotControl.LinearSpring","text":"LinearSpring(stiffness, coord::OperationSpace)\n\nA linear spring acting on the provided coordinate. The spring stiffness  stiffness can be any type that supports multiplication with the coordinate's  configuration, but should be positive definite to ensure it's energy is bounded below, and should not cause allocations when multiplied (i.e. use a Float64 or  an SMatrix).\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.TanhSpring","page":"API","title":"VMRobotControl.TanhSpring","text":"TanhSpring(coord::OperationSpace; stiffness, max_force)\n\nA spring which applies a force of magnitude tanh(|extension|) acting on the  provided coordinate. The spring can be configured in terms of 2 of 3 variables: either a width a max_force, or a stiffness, which are each scalar.\n\nThe force is determined as:     F = kβ tanh(|z|/β) z/|z| where z is the coordinate's configuration, β is the width of the spring, and kis the stiffness. The max force σ iskβ`.\n\nThis is useful as the tanh function saturates to a constant force for large  extensions, which can prevent the robot from applying too much force.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.GaussianSpring","page":"API","title":"VMRobotControl.GaussianSpring","text":"GaussianSpring(σ, stiffness, coordid)\nGaussianSpring(coordid; stiffness, max_force, width)\n\nA spring with a Gaussian energy profile, which is useful for acting as a localized attractive/repulsive force (repulsive when stiffness is negative).\n\nThe energy function is a gaussian with std deviation σ, scaled so that the gradient of it's derivative (the force) is k at |z|=0:     E = -kσ² exp( -|z|²/(2σ²) ) where z is the coordinate's configuration.\n\nWhen calling with keyword arguments, specify any two, as this fully defines  the Gaussian energy function.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.GravityCompensator","page":"API","title":"VMRobotControl.GravityCompensator","text":"GravityCompensator(mass::T, coord::OperationSpace{3}, gravity::SVector{3, T})\nGravityCompensator(;mass, coord, gravity=DEFAULT_GRAVITY)\n\nAn energy storage acting in the opposite direction to the vector gravity. Can be used to compensate for the potential energy of a pointmass on the same coordinate, without affecting inertia.\n\nNote that the stored energy is potentially unbounded for robots with unbounded workspace, but is reported as the potential energy of the mass at the current configuration.\n\nSee also add_gravity_compensator!, add_gravity_compensation!.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.ForceSource","page":"API","title":"VMRobotControl.ForceSource","text":"ForceSource(force_max, power_max, coord)\n\nA power source which applies force  up to force_max in the direction of force_max maximum with power power_max. The force is applied at coord. \n\nIf power max is a scalar, then it represents a maximum power flow into the system. If it is a tuple of two scalars, then the first element bounds power flow into the system, and the second element bounds the power flow out of the system.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.PowerSource","page":"API","title":"VMRobotControl.PowerSource","text":"PowerSource(force_max, power_max, coord)\n\nA power source which applies a force up to force_max in the direction that will inject power into the system up to power_max. Cannot extract power from the system. The force is applied at coord.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.LinearDamper","page":"API","title":"VMRobotControl.LinearDamper","text":"LinearDamper(damping, coord::OperationSpace)\n\nA linear damper acting on the provided coordinate. The damping coefficient  damping can be any type that supports multiplication with the coordinate's  velocity, but should be positive definite to ensure it is dissipative, and should not cause allocations when multiplied (i.e. use a Float64 or an SMatrix).\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.TanhDamper","page":"API","title":"VMRobotControl.TanhDamper","text":"TanhDamper(max_force, width, coord::OperationSpace)\n\nA damper that applies a constant damping force above a certain velocity, using a tanh function. The width parameter determines the shape of the tanh, at 2width, the damping force is ~95% of the  maximum, and at 3width, the damping force is ~99.5% of the maximum.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.RectifiedDamper","page":"API","title":"VMRobotControl.RectifiedDamper","text":"RectifiedDamper(damping, coord::OperationSpace, bounds, flipped, diodic)\n\nA linear damper acting on the provided coordinate only in a certain position  range. If position z is greater than ub, full damping is applied, if it is between the lower bound and upper bound, partial damping is applied, and if it  is less than the lower bound, no damping is applied.\n\nIf flipped is true, this is inverted and the damper is applied when z is  less than the lower bound, and not applied when z is greater than the upper.\n\nIf diodic is true, the damper is applied only when the velocity is positive (or negative if flipped is true).\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.DiodicDamper","page":"API","title":"VMRobotControl.DiodicDamper","text":"DiodicDamper(damping, coord::OperationSpace, flipped)\n\nA that acts only when the velocity is positive (or negative if flipped is  true).\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.LinearInerter","page":"API","title":"VMRobotControl.LinearInerter","text":"LinearInerter(inertance, coord)\n\nA linear inertance with inertance matrix inertance across coordinate coord. \n\nThe inertance matrix should be positive definite, and should multiply with the velocity vector to produce a force vector, or the jacobian to produce an inertance matrix. It should not cause allocation when multiplied (i.e use  SMatrix or Float64).\n\nA linear inerter will have the same inerting effect as a point mass if the inertance equals the mass, and the coordinate is the center of mass, but is  not subject to gravity.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.Inertia","page":"API","title":"VMRobotControl.Inertia","text":"Inertia(inertia::SMatrix{3, 3}, coord)\n\nA rotational inertia. Coord must be a FrameAngularVelocity coordinate.\n\nSee also add_inertia!.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#VMRobotControl.PointMass","page":"API","title":"VMRobotControl.PointMass","text":"PointMass(mass, coord_id)\n\nA point mass with mass mass at coordinate coord. The coord should be a 3 dimensional in the global frame, such as a FrameOrigin or a FramePoint.\n\nThe point mass is subject to gravity. This can be compensated using a GravityCompensator component, or avoided by using a LinearInerter instead of a point mass.\n\n\n\n\n\n","category":"type"}]
}
