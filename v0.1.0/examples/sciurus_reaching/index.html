<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sciurus reaching with obstacle avoidance · VMRobotControl.jl</title><meta name="title" content="Sciurus reaching with obstacle avoidance · VMRobotControl.jl"/><meta property="og:title" content="Sciurus reaching with obstacle avoidance · VMRobotControl.jl"/><meta property="twitter:title" content="Sciurus reaching with obstacle avoidance · VMRobotControl.jl"/><meta name="description" content="Documentation for VMRobotControl.jl."/><meta property="og:description" content="Documentation for VMRobotControl.jl."/><meta property="twitter:description" content="Documentation for VMRobotControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VMRobotControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/introduction/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/building/">Building a mechanism</a></li><li><a class="tocitem" href="../../tutorials/using/">Using a mechanism</a></li><li><a class="tocitem" href="../../tutorials/vms/">Virtual Model Control of a Simulated Robot</a></li><li><a class="tocitem" href="../../tutorials/plotting/">Plotting with Makie.jl</a></li><li><a class="tocitem" href="../../tutorials/simulating/">Simulating with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/control/">Virtual Model Control of a Real Robot using ROS</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Optimization</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../franka_impedance_control/">Franka Impedance Control</a></li><li class="is-active"><a class="tocitem" href>Sciurus reaching with obstacle avoidance</a><ul class="internal"><li><a class="tocitem" href="#Setup-simulation"><span>Setup simulation</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../compliant_path_following/">Franka compliant path following</a></li><li><a class="tocitem" href="../rail_robot/">Pendulum on a Bezier-Spline Rail</a></li></ul></li><li><a class="tocitem" href="../../api/api/">API</a></li><li><a class="tocitem" href="../../developer/developer/">Developer Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Sciurus reaching with obstacle avoidance</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sciurus reaching with obstacle avoidance</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Cambridge-Control-Lab/VMRobotControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Cambridge-Control-Lab/VMRobotControl.jl/blob/main/docs/src/examples/sciurus_reaching.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reaching-with-Obstacle-Avoidance"><a class="docs-heading-anchor" href="#Reaching-with-Obstacle-Avoidance">Reaching with Obstacle Avoidance</a><a id="Reaching-with-Obstacle-Avoidance-1"></a><a class="docs-heading-anchor-permalink" href="#Reaching-with-Obstacle-Avoidance" title="Permalink"></a></h1><p>In this example, we will generate a controller for the sciurus17 robot to reach two targets while  avoiding two obstacles. The reaching controller will be a saturating-spring, linear-damper virtual mechanism, with additional repulsive springs to avoid the obstacles.</p><p>The sciurus17 robot is a many-DOF robot 2 arms, a pivotting waist and 2DOF neck/head.</p><pre><code class="language-julia hljs">using DifferentialEquations
using GLMakie
using StaticArrays
using VMRobotControl</code></pre><p>First, we load the URDF file for the sciurus17 robot, with warnings suppressed, as the URDF file contains some features that are not supported by the URDFParser, but are not necessary for this example. We then add joint limit springs to the robot, to prevent the robot from reaching its joint limits. These act like `buffers&#39; around the joint limits, which will and push back with a spring force as the joint approaches its limits. We also add a linear damper to each joint to make the simulation more realistic, so that the robot does not oscillate indefinitely. Finally, we add the TCPs for the left and right arms of the robot, which will be used for the reaching controller.</p><pre><code class="language-julia hljs">cfg = URDFParserConfig(; suppress_warnings=true)
module_path = joinpath(splitpath(splitdir(pathof(VMRobotControl))[1])[1:end-1])
robot = parseURDF(joinpath(module_path, &quot;URDFs/sciurus17_description/urdf/sciurus17.urdf&quot;), cfg)</code></pre><pre><code class="nohighlight hljs">21DOF Mechanism{Float64} &quot;sciurus17&quot; with 27 frames, 26 joints, 44 coordinates, 74 components</code></pre><p>Add joint limit springs</p><pre><code class="language-julia hljs">joint_limits = cfg.joint_limits
for joint_id in keys(joints(robot))
    limits = joint_limits[joint_id]
    isnothing(limits) &amp;&amp; continue
    add_coordinate!(robot, JointSubspace(joint_id);  id=&quot;$(joint_id)_coord&quot;)
    @assert ~isnothing(limits.lower) &amp;&amp; ~isnothing(limits.upper)
    add_deadzone_springs!(robot, 50.0, (limits.lower+0.1, limits.upper-0.1), &quot;$(joint_id)_coord&quot;)
    add_component!(robot, LinearDamper(0.01, &quot;$(joint_id)_coord&quot;); id=&quot;$(joint_id)_damper&quot;)
end
add_coordinate!(robot, FramePoint(&quot;l_link7&quot;, SVector(0.,  0.08, 0.0)); id=&quot;L TCP&quot;)
add_coordinate!(robot, FramePoint(&quot;r_link7&quot;, SVector(0., -0.08, 0.0)); id=&quot;R TCP&quot;)</code></pre><pre><code class="nohighlight hljs">&quot;R TCP&quot;</code></pre><p>Next we build the virtual mechanism controller. There is no virtual mechanism structure, as the controller we are building does not require any simulated links or joints, only springs/dampers and repulsive springs. We define two targets for the robot to reach, and the position error for each target. On top of these coordinates, we add a saturating spring-damper component, which will act as the reaching controller.</p><pre><code class="language-julia hljs">vms = VirtualMechanismSystem(&quot;sciurus_reaching&quot;, robot)
add_gravity_compensation!(vms, VMRobotControl.DEFAULT_GRAVITY)
vm = vms.virtual_mechanism
add_coordinate!(vm, ReferenceCoord(Ref(SVector(0.5,  0.0, 0.4))); id=&quot;target_1_pos&quot;)
add_coordinate!(vm, ReferenceCoord(Ref(SVector(0.5, -0.1, 0.2))); id=&quot;target_2_pos&quot;)
add_coordinate!(vms, CoordDifference(&quot;.robot.L TCP&quot;, &quot;.virtual_mechanism.target_1_pos&quot;); id=&quot;L pos error&quot;)
add_coordinate!(vms, CoordDifference(&quot;.robot.R TCP&quot;, &quot;.virtual_mechanism.target_2_pos&quot;); id=&quot;R pos error&quot;)

add_component!(vms, TanhSpring(&quot;L pos error&quot;; max_force=10.0, stiffness=1000.0); id=&quot;L spring&quot;)
add_component!(vms, LinearDamper(10.0, &quot;L pos error&quot;); id=&quot;L damper&quot;)
add_component!(vms, TanhSpring(&quot;R pos error&quot;; max_force=10.0, stiffness=1000.0); id=&quot;R spring&quot;)
add_component!(vms, LinearDamper(10.0, &quot;R pos error&quot;); id=&quot;R damper&quot;)</code></pre><pre><code class="nohighlight hljs">&quot;R damper&quot;</code></pre><p>We define two obstacle positions, and for each frame in each arm attach a repulsive spring between the frame origin and the obstacle position. The repulsive spring will push the frame origin away from the obstacle, with a force that decreases as the frame origin moves away from the obstacle, according to the Gaussian potential energy of the spring.</p><pre><code class="language-julia hljs">obstacles = Dict(
    &quot;obstacle_1&quot; =&gt; SVector(0.4,  0.1, 0.3),
    &quot;obstacle_2&quot; =&gt; SVector(0.3, -0.2, 0.1)
)
collision_frames = String[]
for i in 1:7
    push!(collision_frames, &quot;l_link$i&quot;)
    push!(collision_frames, &quot;r_link$i&quot;)
end
for (id, pos) in obstacles
    add_coordinate!(vm, FramePoint(&quot;root_frame&quot;, pos); id)
end
for id in collision_frames
    add_coordinate!(robot, FrameOrigin(&quot;$id&quot;); id=&quot;$id frame origin&quot;)
    for obstacle in keys(obstacles)
        add_coordinate!(vms, CoordDifference(&quot;.robot.$id frame origin&quot;, &quot;.virtual_mechanism.$obstacle&quot;); id=&quot;$obstacle $id error&quot;)
        add_component!(vms, GaussianSpring(&quot;$obstacle $id error&quot;; max_force=-10.0, width=0.05); id=&quot;$obstacle $id spring&quot;)
    end
end</code></pre><h2 id="Setup-simulation"><a class="docs-heading-anchor" href="#Setup-simulation">Setup simulation</a><a id="Setup-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-simulation" title="Permalink"></a></h2><p>We define functions to move the targets in a circular motion, and to set the target positions and velocities in the <code>f_control</code> function. We then define the <code>f_setup</code> function to get the coordinate IDs of the target positions and velocities, to be used in the <code>f_control</code> function.</p><p>We then define the timespan, initial joint angles, joint velocities, and gravity vector for the simulation. We create a dynamics cache, and an ODE problem, and solve the ODE problem using the Tsit5 solver from DifferentialEquations.jl.</p><pre><code class="language-julia hljs">target_1_pos(t) = SVector(0.5,  0.0, 0.3) + SVector(0.2*cos(t), 0.0, 0.2*sin(t))
target_1_vel(t) = SVector(-0.2*sin(t), 0.0, 0.2*cos(t))
target_2_pos(t) = SVector(0.5, -0.1, 0.2) + SVector(0.0, 0.2*sin(t), 0.2*cos(t))
target_2_vel(t) = SVector(0.2*cos(t), 0.0, -0.2*sin(t))
function f_setup(cache)
    id1 = get_compiled_coordID(cache, &quot;.virtual_mechanism.target_1_pos&quot;)
    id2 = get_compiled_coordID(cache, &quot;.virtual_mechanism.target_2_pos&quot;)
    val1 = cache[id1].coord_data.val
    val2 = cache[id2].coord_data.val
    vel1 = cache[id1].coord_data.vel
    vel2 = cache[id2].coord_data.vel
    (val1, val2, vel1, vel2)
end
function f_control(cache, t, args, extra)
    (val1, val2, vel1, vel2) = args
    val1[] = target_1_pos(t)
    vel1[] = target_1_vel(t)
    val2[] = target_2_pos(t)
    vel2[] = target_2_vel(t)
    false
end
tspan = (0., 6π)
dcache = new_dynamics_cache(compile(vms))
q = zero_q(dcache.vms)
q̇ = zero_q̇(dcache.vms)
g = VMRobotControl.DEFAULT_GRAVITY
prob = get_ode_problem(dcache, g, q, q̇, tspan; f_setup, f_control)
@info &quot;Simulating Sciurus reaching with obstacle avoidance problem.&quot;
sol = solve(prob, Tsit5(); maxiters=1e5, abstol=1e-3, reltol=1e-3); # Low tol to speed up simulation</code></pre><pre><code class="nohighlight hljs">[ Info: Simulating Sciurus reaching with obstacle avoidance problem.
</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>We create a figure with two scenes, for two different camera angles. We plot the robot, the targets, the TCPs, and the obstacles in the scene. We use observables for the time and the kinematics cache, which will be updated in the function <code>animate_robot_odesolution</code>, causing any plots that depend upon these observables to be updated.</p><pre><code class="language-julia hljs">fig = Figure(; size = (2*720, 720), figure_padding=1.5, fontsize=32)
display(fig)
lscenes = (LScene(fig[1, 1]; show_axis=false), LScene(fig[1, 2]; show_axis=false))
cams = map(ls -&gt; cam3d!(ls; center=false), lscenes)
plotting_t = Observable(0.0)
plotting_kcache = Observable(new_kinematics_cache(compile(vms)))

target_scatter_kwargs = (;
    color=:green,
    marker=:+,
    markersize=15,
    label=&quot;Targets&quot;,
    transparency=true ## Avoid ugly white outline artefact on markers
)
tcp_scatter_kwargs = (;
    color=:blue,
    marker=:x,
    markersize=15,
    label=&quot;TCPs&quot;,
    transparency=true ## Avoid ugly white outline artefact on markers
)

for ls in lscenes
    # Show robot
    robotvisualize!(ls, plotting_kcache; overdraw=false)

    # Label target and TCP
    target_1_pos_id = get_compiled_coordID(plotting_kcache[], &quot;.virtual_mechanism.target_1_pos&quot;)
    target_2_pos_id = get_compiled_coordID(plotting_kcache[], &quot;.virtual_mechanism.target_2_pos&quot;)
    l_tcp_pos_id = get_compiled_coordID(plotting_kcache[], &quot;.robot.L TCP&quot;)
    r_tcp_pos_id = get_compiled_coordID(plotting_kcache[], &quot;.robot.R TCP&quot;)
    scatter!(ls, plotting_kcache, [target_1_pos_id, target_2_pos_id]; target_scatter_kwargs...)
    scatter!(ls, plotting_kcache, [l_tcp_pos_id, r_tcp_pos_id]; tcp_scatter_kwargs...)
    for (id, pos) in obstacles ## Show obstacles
        small_sphere = Sphere(Point3f(pos...), 0.05)
        large_sphere = Sphere(Point3f(pos...), 0.1)
        mesh!(ls, small_sphere; color=:magenta, transparency=true)
        poly!(ls, Point3f[]; color=:magenta, label=&quot;Obstacles&quot;) ## Just for legend entry
        mesh!(ls, large_sphere; color=:cyan, alpha=0.1, transparency=true)
        poly!(ls, Point3f[]; color=:cyan, label=&quot;Repulsive field&quot;) ## Just for legend entry
    end
end
cams[1].lookat[] = [0., 0., 0.3]
cams[1].eyeposition[] = [1.5, 0., 0.3]
cams[2].lookat[] = [0.4, 0, 0.3]
cams[2].eyeposition[] = [0.4, 1.5, 0.3]

leg = Legend(fig[1, 1], lscenes[1]; merge=true, tellwidth=false, halign=:left, valign=:top)
savepath = joinpath(module_path, &quot;docs/src/assets/sciurus_reaching.mp4&quot;)
animate_robot_odesolution(fig, sol, plotting_kcache, savepath; t=plotting_t, f_setup, f_control, fastforward=1.0, fps=20)</code></pre><pre><code class="nohighlight hljs">&quot;/home/runner/work/VMRobotControl.jl/VMRobotControl.jl/docs/src/assets/sciurus_reaching.mp4&quot;</code></pre><video controls width="100%" height="auto" autoplay loop>
<source src="../../assets/sciurus_reaching.mp4" type="video/mp4">
</video><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../franka_impedance_control/">« Franka Impedance Control</a><a class="docs-footer-nextpage" href="../compliant_path_following/">Franka compliant path following »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 21 January 2025 15:21">Tuesday 21 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
